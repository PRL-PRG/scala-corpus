---
title: Implicit Analysis
authors: Filip Krikava, Heather Miller and Jan Vitek
output:
  html_document:
    code_folding: hide
    theme: united
    toc: true
    toc_float: true
params:
  corpus_dir: /var/lib/scala/corpora/github
  corpus_url: http://prl1.ele.fit.cvut.cz:8149
  lib_dir: ../inc
  report_name: implicits-analysis
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
source(file.path(params$lib_dir, "setup.R"))
```

```{r define outputs}
OUT_IMPLICITS_OVERVIEW_PDF <- path(output_dir, "implicits-overview.pdf")
OUT_PATTERNS_OVERVIEW_DECLARATIONS_TEX <- path(output_dir, "patterns-overview-declarations.tex")
OUT_PATTERNS_OVERVIEW_CALLSITES_TEX <- path(output_dir, "patterns-overview-callsites.tex")
OUT_PATTERNS_DECLARATIONS_TEX <- path(output_dir, "patterns-declarations.tex")
OUT_PATTERNS_CALLSITES_TEX <- path(output_dir, "patterns-callsites.tex")
OUT_PATTERNS_CSV <- path(output_dir, "patterns.csv")
OUT_IMPLICIT_CALLSITES_RATIO_PDF <- path(output_dir, "implicit-callsites-ratio.pdf")
OUT_CALLSITES_LOCATION_RATIO_PDF <- path(output_dir, "callsites-location-ratio.pdf")
```

## Introduction

The notebook contains the automated analysis of the results of the implicits extraction pipeline.
Some of the analysis in the paper was done manually by inspecting the data presented in the tables rendered by this script.

## Data Definition

The following is the summary of the data exported from the corpus.

### Implicit Declarations

The `r CLEAN_IMPLICIT_DECLARATIONS` file contains all the implicit declarations, including all defs with implicit parameters.
It contains the following columns:

- `project_id` (chr): project name as `github-user-name--github-repository-name`
- `module_id` (chr): module id as `project_id::group_id:artifact_id:version:platform`
- `group_id` (chr): organization name
- `artifact_id` (chr): artifact name
- `version` (chr): version
- `kind` (chr): one of `DEF`, `CLASS`, `VAL`, `VAR`, `OBJECT`, `MACRO`, `PARAMETER`
- `declaration_id` (chr): fully qualified name of the declaration
- `name` (chr): just the declaration name
- `location_path` (chr): the folder or jar file in which it is defined
- `location_uri` (chr): the file name within that folder or jar file
- `location_pos` (chr): `start_line:start_coulmn` in case it was available or `NA`
- `location_scope` (chr): a `;`-separated tags:
    - `compile` - in a compile scope
    - `test` - in a test scope
    - `managed` - in an SBT managed directory (i.e. a generated source)
    - `dependency` - in a dependency in respect to the module (group_id:artifact_id)
    - `transitive` - in a transitive depenency
- `compilation_unit` (chr): the fully qualified name of the enclosing compilation unit
- `def_group_id` (chr): the organization name of the library where the decalration originates
- `def_artifact_id` (chr): the artifact name of the library where the decalration originates
- `def_version` (chr): the version of the library where the decalration originates
- `is_implicit` (lgl): does it come with the `implicit` keyword?
- `is_companion` (lgl): is it the `implicit def` generated for an `implicit class`?
- `access` (chr): access modifiers (e.g. `PUBLIC`, `PRIVATE`, ...)
- `annotations` (char): a `;`-separated list of attached annotation 
- `num_type_parameters` (int): number of type parameters it defines
- `num_parameter_lists` (int): number of parameter lists
- `num_parameters` (int): total number of parameters
- `num_implicit_parameters` (int): number of implicit parameters
- `github_url` (chr): a link to github if available to see the actual code

It was created by [ImplicitDeclarationExporter.scala](https://github.com/PRL-PRG/scala-implicits-analysis/blob/oopsla19/libs/tools/src/main/scala/cz/cvut/fit/prl/scala/implicits/tools/ 	ImplicitDeclarationExporter.scala).

### Implicit Call Sites

The `r CLEAN_IMPLICIT_CALLSITES` file contains all the callsites involving implicits.
It contains the following columns:

- `project_id` (chr): project name as `github-user-name--github-repository-name`
- `module_id` (chr): module id as `project_id::group_id:artifact_id:version:platform`
- `group_id` (chr): organization name
- `artifact_id` (chr): artifact name
- `version` (chr): version
- `callsite_id` (int): an id of a call site which is unique within a module
- `parent_id` (int): an id to a parent call site in the case this one is nested or `NA`
- `code` (chr): an up to 50 chars snippet of the call site code
- `nested_calls` (chr): `;`-separated list of call nested call sites
- `arguments` (chr): `;`-separated list of arguments declaration ids
- `declaration_id` (chr): a declaration id of the function/method
- `local` (chr): is it `project`-local, `module`-local or `NA`
- `location_path` (chr): the folder or jar file in which it is defined
- `location_uri` (chr): the file name within that folder or jar file
- `location_pos` (chr): `start_line:start_coulmn` in case it was available or `NA`
- `location_scope` (chr): a `,`-separated tags:
    - `compile` - in a compile scope
    - `test` - in a test scope
    - `managed` - in an SBT managed directory (i.e. a generated source)
    - `dependency` - in a dependency in respect to the module (group_id:artifact_id)
    - `transitive` - in a transitive depenency
- `num_type_parameters` (int): number of type parameters it has
- `num_implicit_parameters` (int): number of implicit parameters
- `github_url` (chr): a link to github if available to see the actual code

It was created by [ImplicitCallSitesExporter.scala](https://github.com/PRL-PRG/scala-implicits-analysis/blob/oopsla19/libs/tools/src/main/scala/cz/cvut/fit/prl/scala/implicits/tools/ 	ImplicitCallSitesExporter.scala).

### Implicit Conversions

The `r CLEAN_IMPLICIT_CONVERSIONS` file contains all the callsites involving implicits.
It contains the following columns:

- `project_id` (chr): project name as `github-user-name--github-repository-name`
- `module_id` (chr): module id as `project_id::group_id:artifact_id:version:platform`
- `declaration_id` (chr): a declaration id of the implicit conversion
- `from` (chr): a declaration id of the from parameter
- `from_groupId` (chr): organization name of the library where from is defined
- `from_artifactId` (chr): artifact name of the library where from is defined
- `from_version` (chr): version of the library where from is defined
- `from_scope` (chr): a `,`-separated tags:
    - `compile` - in a compile scope
    - `test` - in a test scope
    - `managed` - in an SBT managed directory (i.e. a generated source)
    - `dependency` - in a dependency in respect to the module (group_id:artifact_id)
    - `transitive` - in a transitive depenency
- `from_compilation_unit` (chr): the fully qualified name of the enclosing compilation unit of the to parameter
- `from_language` (chr): either `SCALA` or `JAVA`
- `to` (chr): a declaration id of the to parameter
- `to_groupId` (chr): organization name of the library where to is defined
- `to_artifactId` (chr): artifact name of the library where to is defined
- `to_version` (chr): version of the library where to is defined
- `to_scope` (chr): a `,`-separated tags:
    - `compile` - in a compile scope
    - `test` - in a test scope
    - `managed` - in an SBT managed directory (i.e. a generated source)
    - `dependency` - in a dependency in respect to the module (group_id:artifact_id)
    - `transitive` - in a transitive depenency
- `to_compilation_unit` (chr): the fully qualified name of the enclosing compilation unit of the to parameter
- `to_language` (chr): either `SCALA` or `JAVA`

It was created by [ImplicitConversionExporter.scala](https://github.com/PRL-PRG/scala-implicits-analysis/blob/oopsla19/libs/tools/src/main/scala/cz/cvut/fit/prl/scala/implicits/tools/ 	ImplicitConversionExporter.scala).

### Implicit parameters

The data frame in `r CLEAN_IMPLICIT_PARAMETERS` represents implicit parameter declarations.
For each declaration that carries implicit argument list it contains the following information:

- `project_id` (chr): project name as `github-user-name--github-repository-name`
- `module_id` (chr): module id as `project_id::group_id:artifact_id:version:platform`
- `group_id` (chr): organization name
- `artifact_id` (chr): artifact name
- `version` (chr): version
- `declaration_id` (chr): a declaration id of the implicit conversion
- `declaration_kind` (chr): kind of the declaration
- `declaration_is_implicit` (lgl): is the declaration implicit
- `declaration_is_companion` (lgl): is the declaration a companion def to an implicit class
- `def_group_id` (chr): organization name that defines this declaration
- `def_artifact_id` (chr): artifact name that defines this declaration 
- `def_version` (chr): artifact version
- `def_location_scope`  (chr): a `,`-separated tags:
    - `compile` - in a compile scope
    - `test` - in a test scope
    - `managed` - in an SBT managed directory (i.e. a generated source)
    - `dependency` - in a dependency in respect to the module (group_id:artifact_id)
    - `transitive` - in a transitive depenency
- `parameter_id` (chr): id of the parameter
- `name` (chr): name of the parameter
- `code` (chr): code representation
- `type_id` (chr): id of the parameter type
- `type_kind` (chr): kind of the parameter type
- `type_group_id` (chr): organization name that defines this type
- `type_artifact_id` (chr): artifact name that defines this type
- `type_version` (chr): version of the artifact
- `type_location_scope` (chr): a `,`-separated tags:
    - `compile` - in a compile scope
    - `test` - in a test scope
    - `managed` - in an SBT managed directory (i.e. a generated source)
    - `dependency` - in a dependency in respect to the module (group_id:artifact_id)
    - `transitive` - in a transitive depenency
- `type_local` (chr): either `project` or `module` local, or `NA` for for project external symbols
- `resolved_type_id` (chr): resolved type declaration id
- `resolved_type_kind` (chr): resolved type kind
- `num_type_arguments` (int): number of type arguments the type declaration has
- `num_type_argument_refs` (int): number of type arguments the type declaration has that are type parameters

They were extracted using [ImplicitParameterExporter.scala](https://github.com/PRL-PRG/scala-implicits-analysis/blob/oopsla19/libs/tools/src/main/scala/cz/cvut/fit/prl/scala/implicits/tools/ImplicitParameterExporter.scala).

## Tests

```{r}
testthat::expect_equal(
  remove_scala_version_suffix(
    c("name_scala_6.2", "name_scala-ng_3.2", "name-scala_2-5", "name-scala_2.11", "name-scala_sjs0.6", "name_scala_native0.3", "name-scala_6.2_sjs0.6_2.12")
  ), 
    c("name_scala",     "name_scala-ng",     "name-scala",     "name-scala",      "name-scala",        "name_scala",           "name-scala")
)
```

## Loading data

First, we load the corpus and raw data that came from the `export-implicit` task.

```{r load all}
raw_corpus <- read_csv(CAT_CORPUS, col_types=cols(
  project_id = col_character(),
  origin = col_character(),
  commit_count = col_integer(),
  dejavu_duplication = col_double(),
  gh_stars = col_integer(),
  scaladex = col_logical(),
  scala_code = col_integer(),
  scala_version = col_character(),
  updated_scala_version = col_character(),
  declarations = col_integer(),
  explicit_callsites = col_integer(),
  cat = col_character()
))

raw_all_declarations <- load_if_not_present(raw_all_declarations, read_data(CLEAN_IMPLICIT_DECLARATIONS))
raw_all_callsites <- load_if_not_present(raw_all_callsites, read_data(CLEAN_IMPLICIT_CALLSITES))
raw_all_conversions <- load_if_not_present(raw_all_conversions, read_data(CLEAN_IMPLICIT_CONVERSIONS))
raw_all_parameters <- load_if_not_present(raw_all_parameters, read_data(CLEAN_IMPLICIT_PARAMETERS))
```

Note: 
- The conditional load is for interactive development of this notebook.
  Loading takes time and they these variables should only be used to derive the actual variables with which we work.

```{r aux reset environment, include=F}
reset_environment <- function() {
  vars <- ls(envir = globalenv())
  vars <- vars[!startsWith(vars, "raw_all")]
  message("Removing: ", str_c(vars, ", "))
  rm(list=vars, envir=globalenv())
}
```

The corpus has duplicates since the test category includes test code from other projects.
Here we create auxiliary variables to help to work around it:

```{r corpus split}
corpus_unique <- 
  raw_corpus %>%
  filter(cat != "test") %>%
  select(-scala_code, explicit_callsites)
```

```{r corpus check}
stopifnot(nrow(filter(raw_corpus, cat != "test")) == nrow(corpus_unique))
stopifnot(nrow(corpus_unique) == 7280)
stopifnot(nrow(filter(raw_corpus, cat == "test")) == 5438)

# double check that there are no duplicates in unique corpus
stopifnot(!any(duplicated(corpus_unique$project_id)))
```

Double check we agree on projects

```{r check project ids in raw_all data frames}
stopifnot(raw_all_declarations %>% anti_join(corpus_unique, by="project_id") %>% nrow() == 0)
stopifnot(raw_all_callsites    %>% anti_join(corpus_unique, by="project_id") %>% nrow() == 0)
stopifnot(raw_all_conversions  %>% anti_join(corpus_unique, by="project_id") %>% nrow() == 0)
stopifnot(raw_all_parameters   %>% anti_join(corpus_unique, by="project_id") %>% nrow() == 0)
```

Double check there are no duplicates

```{r check no duplicates in declarations}
stopifnot(nrow(filter(count(raw_all_declarations, module_id, declaration_id), n != 1)) == 0)
```

### Mark block-local declaration_id

```{r}
mark_block_locals <- function(df) mutate(df, is_block_local=str_detect(declaration_id, "^local\\d+::\\d+"))

patched_all_declarations <- mark_block_locals(raw_all_declarations)
patched_all_callsites    <- mark_block_locals(raw_all_callsites)
patched_all_conversions  <- mark_block_locals(raw_all_conversions)
patched_all_parameters   <- mark_block_locals(raw_all_parameters)

stopifnot(nrow(patched_all_declarations) == nrow(raw_all_declarations))
stopifnot(nrow(patched_all_callsites)    == nrow(raw_all_callsites))
stopifnot(nrow(patched_all_conversions)  == nrow(raw_all_conversions))
stopifnot(nrow(patched_all_parameters)   == nrow(raw_all_parameters))
```

### Hot patches

#### Fix for #72 (block local declarations without location):

```{r fix #72}
fix_wrong_declarations <- filter(patched_all_declarations, is_block_local, is.na(location_pos))

patched_all_declarations <- anti_join(patched_all_declarations, fix_wrong_declarations, by=c("module_id", "declaration_id"))
patched_all_callsites    <- anti_join(patched_all_callsites,    fix_wrong_declarations, by=c("module_id", "declaration_id"))
patched_all_conversions  <- anti_join(patched_all_conversions,  fix_wrong_declarations, by=c("module_id", "declaration_id"))
patched_all_parameters   <- anti_join(patched_all_parameters,   fix_wrong_declarations, by=c("module_id", "declaration_id"))

stopifnot(nrow(patched_all_declarations) + nrow(fix_wrong_declarations) == nrow(raw_all_declarations))
rm(fix_wrong_declarations)
```

#### Fix for #73 (missing conversions in declarations)

```{r fix #73}
fix_missing_declarations <-
  anti_join(patched_all_conversions, patched_all_declarations, by=c("module_id", "declaration_id"))

# there should be only two cases from xsbt, which comes in by a mistake
stopifnot(nrow(fix_missing_declarations) == 2)

patched_all_conversions <-
  anti_join(patched_all_conversions, fix_missing_declarations, by=c("module_id", "declaration_id"))

rm(fix_missing_declarations)
```

#### Use implicit class location for companion defs

```{r fix locations in implicit companions}
fix_implicit_classes <- 
  filter(patched_all_declarations, kind=="CLASS", is_module_local(location_uri)) %>%
  select(module_id, declaration_id, location_path, location_uri, location_pos) %>%
  mutate(
    # this will convert a type id into a def id
    declaration_id=str_replace(declaration_id, "#$", "().")
  )

fix_implicit_companions <- 
  filter(patched_all_declarations, kind=="DEF", is_companion, location_scope %in% c("compile", "test"))

# it is ok to have a few due to js/jvm/native thing
# this actually prevents duplicates
fix_missed <- 
  anti_join(fix_implicit_companions, fix_implicit_classes, by=c("module_id", "declaration_id")) %>% 
  select(module_id, declaration_id)

fix_before <- select(patched_all_declarations, module_id, declaration_id, location_path, location_uri, location_pos)

patched_all_declarations <-
  patched_all_declarations %>%
    left_join(fix_implicit_classes, by=c("module_id", "declaration_id")) %>%
    mutate(
      location_path=if_else(is.na(location_path.y), location_path.x, location_path.y), 
      location_uri= if_else(is.na(location_uri.y),  location_uri.x,  location_uri.y), 
      location_pos= if_else(is.na(location_pos.y),  location_pos.x,  location_pos.y)
    ) %>%
    select(
      -location_path.x, -location_path.y, 
      -location_uri.x,  -location_uri.y, 
      -location_pos.x,  -location_pos.y
    )

fix_after <- select(patched_all_declarations, module_id, declaration_id, location_path, location_uri, location_pos)

# TODO: #74
fix_diff <- left_join(fix_before, fix_after, by=c("module_id", "declaration_id")) %>%
  filter(
    location_path.x != location_path.y |
    location_uri.x != location_uri.y |
    location_pos.x != location_pos.y
  )

rm(fix_missed)
rm(fix_implicit_classes)
rm(fix_implicit_companions)
rm(fix_diff)
```

### Checks

```{r check that we see all}
stopifnot(nrow(anti_join(patched_all_callsites,   patched_all_declarations, by=c("module_id", "declaration_id"))) == 0)
stopifnot(nrow(anti_join(patched_all_conversions, patched_all_declarations, by=c("module_id", "declaration_id"))) == 0)
stopifnot(nrow(anti_join(patched_all_parameters,  patched_all_declarations, by=c("module_id", "declaration_id"))) == 0)
```

## Preprocessing

The corpus contain two things:
- declarations
- callsites

In the analysis we look at them separately.
In terms of declarations, this means that that analyzed declarations are only the declarations seen in the corpus, i.e. for which we have source code.
In terms of callsites, they use different set of declarations, some of which might be included in the local declarations others are coming from external dependencies.

The declarations for which we have source code are called _local declarations_, the one which comes from external dependencies are _external declarations_.

### Index

```{r}
project_idx <- transmute(corpus_unique, project_id, pid=1:n())
modules <- distinct(raw_all_declarations, project_id, module_id)
module_idx <- mutate(modules, mid=1:n())
idx <- left_join(module_idx, project_idx, by="project_id")

# module names must be unique
stopifnot(nrow(count(modules, module_id) %>% filter(n > 1)) == 0)
# no module_id duplication in idx
stopifnot(!any(duplicated(idx$module_id)))

index <- function(df) {
  df %>%
  left_join(idx, by=c("project_id", "module_id")) %>%
  select(pid, mid, declaration_id, everything())
}
```

### Corpus

```{r}
corpus <-
  corpus_unique %>%
  left_join(project_idx, by="project_id")
```

### Declarations

The `declarations_all` contains all declarations marked as implicit that are either local

```{r all declarations}
declarations_all <- 
  patched_all_declarations %>%
  # remove duplicates
  filter(
    # remove implicit class as it is there already in the desugared version
    kind != "CLASS",    
    # remove parameters since they are also in defs and raw_all_paramteres
    kind != "PARAMETER" 
  ) %>%
  # cleanup
  expand_scope(prefix="def_") %>%
  expand_is_from_scala(prefix="def_") %>%
  index() %>%
  # TODO: these should be done in the extractor
  mutate(
    # fix NA, here 0 is perfectly sensible
    num_implicit_parameters=replace_na(num_implicit_parameters, 0),
    # fix compilation unit
    compilation_unit=normalize_compilation_unit(compilation_unit),
    # access info
    def_is_access_specified=access!="NOT_SPECIFIED",
    def_is_public=access=="PUBLIC",
    def_is_private=startsWith(access, "PRIVATE"),
    def_is_protected=startsWith(access, "PROTECTED"),
    # platform
    def_is_jvm=str_detect(module_id, ":jvm$"),
    def_is_js=str_detect(module_id, ":js$"),
    def_is_native=str_detect(module_id, ":native$"),
    def_platform=str_replace(module_id, ".*:(jvm|js|native)$", "\\1"),
    # add def_library
    def_library=normalize_library(def_group_id, remove_scala_version_suffix(def_artifact_id), def_platform),
    # local definitons must be in scala file
    def_is_module_local=is_module_local(location_uri),
    def_path=normalize_path(location_path, location_uri)
  ) %>%
  # so we can match easily column names with starts_with
  rename(
    def_compilation_unit=compilation_unit,
    def_kind=kind,
    def_is_companion=is_companion,
    def_is_implicit=is_implicit,
    def_location_scope=location_scope,
    def_location_path=location_path,
    def_location_uri=location_uri,
    def_github_url=github_url
  )
```

```{r check declarations}
stopifnot(nrow(declarations_all) == nrow(filter(patched_all_declarations, !(kind %in% c("PARAMETER", "CLASS")))))
stopifnot(all(count(declarations_all, def_platform)$def_platform %in% c("jvm", "js", "native")))
# check the number of declarations coming from dependencies
stopifnot(
  nrow(filter(declarations_all, def_is_in_dependency)) == 
    nrow(filter(patched_all_declarations, !(kind %in% c("PARAMETER", "CLASS")), str_detect(location_scope, "dependency")))
)
```

Check the mutually exclusive flags:

```{r check declarations mutual flag}
check_declarations <-
  declarations_all %>%
    mutate(
      check_platform=def_is_jvm + def_is_js + def_is_native,
      check_access=ifelse(def_is_access_specified, def_is_public + def_is_private + def_is_protected, 1)
    ) %>%
    filter(
      check_platform != 1,
      check_access != 1
    )

stopifnot(nrow(check_declarations) == 0)

rm(check_declarations)
```

### Local implicits declarations

```{r local declarations}
declarations_local <- 
  declarations_all %>%
  filter(def_is_module_local)
```

```{r local declarations checks}
stopifnot(all(declarations_local$def_is_module_local))
# all local declarations should have a path (otherwise, how could they be local)
stopifnot(all(!is.na(declarations_local$def_location_uri)))
# all local declarations should be in a .scala file
stopifnot(nrow(filter(declarations_local, !is_module_local(def_location_uri))) == 0)
```

There are duplicates in the corpus. They do not need to be full project clones, just few files.
Since we do not have any reliable way of telling which one is original and the overall level is low, we keep them.

```{r local declarations duplicates}
declarations_local_duplication <-
  declarations_local %>% 
  semi_join(
    count(declarations_local, def_library, declaration_id) %>% filter(n > 1), 
    by=c("declaration_id", "def_library")
  )

overview_table(
  r("Duplicate local declarations", declarations_local_duplication),
  r("Duplicate local declarations pct", ratio(declarations_local_duplication, declarations_local)),
  r("Corpus dejavu duplication mean pct", percent(mean(corpus_unique$dejavu_duplication, na.rm=T)))
)
```

### Block local declarations

```{r local block local declarations}
declarations_local_block <- filter(declarations_local, is_block_local)
overview_table(
  r("block local implicit declarations", declarations_local_block),
  r("block local implicit declarations pct", ratio(declarations_local_block, declarations_local))
)
```

### Callsites

```{r callsites}
callsites_all <- 
  patched_all_callsites %>%
  # cleanup
  expand_scope() %>%
  index() %>%
  # bring declaration information
  left_join(
    select_at(
      declarations_all,
      vars(
        mid,
        declaration_id, 
        starts_with("def_")
      )
    ), 
    by=c("mid", "declaration_id")
  )
```

```{r check callsites}
# the number of callsites should be the same
stopifnot(nrow(patched_all_callsites) == nrow(callsites_all))
# check we have a declaration in the declaration_all for all callsites
stopifnot(!any(is.na(callsites_all$def_library)))
stopifnot(!any(is.na(callsites_all$def_group_id)))
stopifnot(!any(is.na(callsites_all$def_kind)))
```

### Conversion

```{r conversions}
conversions_all <- 
  patched_all_conversions %>%
  # cleanup
  expand_scope(scope_column=from_scope, prefix="from_") %>%
  expand_scope(scope_column=to_scope, prefix="to_") %>%
  index() %>%
  # bring declaration information
  left_join(
    select_at(
      declarations_all,
      vars(
        mid,
        declaration_id,
        starts_with("def_")
      )
    ), 
    by=c("mid", "declaration_id")
  ) %>%
  mutate(
    # remove version suffix
    from_artifact_id=remove_scala_version_suffix(from_artifact_id),
    to_artifact_id=remove_scala_version_suffix(to_artifact_id),
    # fix compilation unit
    from_compilation_unit=normalize_compilation_unit(from_compilation_unit),
    to_compilation_unit=normalize_compilation_unit(to_compilation_unit),
    # paths
    from_path=normalize_path(from_location_path, from_location_uri),
    to_path=normalize_path(to_location_path, to_location_uri)
  )
```

```{r check conversions}
# the number of callsites should be the same
stopifnot(nrow(patched_all_conversions) == nrow(conversions_all))
# check we have a declaration in the declaration_all for all callsites
stopifnot(!any(is.na(conversions_all$def_library)))
stopifnot(!any(is.na(conversions_all$def_group_id)))
stopifnot(!any(is.na(conversions_all$def_kind)))
```

#### Local convesions

```{r local conversions}
conversions_local <-
  conversions_all %>%
  filter(def_is_module_local)
```

Note:
- The `conversions_local` need to be counted this way. Using `semi_join(conversions_all, declarations_local, by=c("def_library", "declaration_id"))`
  will lead to a wrong result since the `conversion_local` contains all encountered conversions, many of which comes from external depenedncies

```{r local conversions checks}
stopifnot(all(conversions_local$def_is_module_local))
# all local, non-block-local conversion should have a unique path at a module level
stopifnot(nrow(count(filter(conversions_local, !is_block_local), mid, declaration_id, def_path) %>% filter(n > 1)) == 0)
```

```{r local conversion duplication}
conversions_local_duplication <-
  conversions_local %>%
  semi_join(
    count(conversions_local, def_library, declaration_id) %>% filter(n > 1), 
    by=c("declaration_id", "def_library")
  )

overview_table(
  r("Duplicate local conversions", conversions_local_duplication),
  r("Duplicate local conversions pct", ratio(conversions_local_duplication, conversions_local))
)
```

### Parameters

```{r parameters}
parameters_all <- 
  patched_all_parameters %>%
  # TODO: the extractor should output less
  select_at(vars(-(declaration_kind:declaration_is_implicit), -starts_with("def"))) %>%
  expand_scope(type_location_scope, "type_") %>%
  # cleanup
  index() %>%
  # bring declaration information
  left_join(
    select_at(
      declarations_all,
      vars(
        mid,
        declaration_id, 
        starts_with("def_")
      )
    ), 
    by=c("mid", "declaration_id")
  ) %>%
  mutate(
    type_library=normalize_library(type_group_id, remove_scala_version_suffix(type_artifact_id), def_platform),
  )
```

```{r check parameters}
# the number of parameters should be the same
stopifnot(nrow(patched_all_parameters) == nrow(parameters_all))
# check we have a declaration in the declaration_all for all parameters
stopifnot(!any(is.na(parameters_all$def_library)))
stopifnot(!any(is.na(parameters_all$def_group_id)))
stopifnot(!any(is.na(parameters_all$def_kind)))
```

```{r}
parameters_local <-
  parameters_all %>%
  filter(def_is_module_local)
```

## Implicits overview

### Update corpus

```{r}
summarise_count_per_category <- function(df, test_column, new_column_name) {
  test_column <- enquo(test_column)
  
  df %>%
    group_by(project_id) %>%
    summarise(
      test=      sum(!!test_column),
      lib=       sum(! (!!test_column)),
      app_small= lib,
      app_big=   lib
  ) %>%
  gather("cat", !!new_column_name, -project_id)
}
```

```{r compute declarations per project}
declarations_per_projects <-
  declarations_local %>%
  summarise_count_per_category(def_is_in_test, "implicit_declarations")
```

```{r compute implicit callsites per project}
callsites_per_projects <-
  callsites_all %>%
  summarise_count_per_category(is_in_test, "implicit_callsites")
```

```{r}
stopifnot(!any(is.na(raw_corpus$explicit_callsites)))
```

```{r update category corpus}
corpus_cat <-
  raw_corpus %>%
  left_join(declarations_per_projects, by=c("project_id", "cat")) %>% 
  left_join(callsites_per_projects, by=c("project_id", "cat")) %>% 
  mutate(
    implicit_declarations=replace_na(implicit_declarations, 0),
    implicit_callsites=replace_na(implicit_callsites, 0),
    callsites=implicit_callsites + explicit_callsites
  )

stopifnot(nrow(corpus_cat)==nrow(raw_corpus))
stopifnot(!any(is.na(corpus_cat$implicit_declarations)))
stopifnot(!any(is.na(corpus_cat$implicit_callsites)))
```

```{r}
corpus_noncat <-
  corpus_cat %>%
  mutate(cat=if_else(cat=="test", "test", "main")) %>%
  group_by(cat, project_id) %>%
  summarise_at(vars(scala_code, implicit_declarations, implicit_callsites, explicit_callsites), sum) %>%
  gather(variable, value, -(cat:project_id)) %>%
  unite(temp, cat, variable) %>%
  spread(temp, value) %>%
  mutate_at(vars(-project_id), ~replace_na(., 0)) %>%
  mutate(
    implicit_declarations=test_implicit_declarations + main_implicit_declarations,
    scala_code=test_scala_code + main_scala_code,
    implicit_callsites=test_implicit_callsites + main_implicit_callsites,
    explicit_callsites=test_explicit_callsites + main_explicit_callsites,
    callsites=implicit_callsites + explicit_callsites
  ) %>% 
  left_join(
    select(corpus, -explicit_callsites),
    by="project_id"
  ) 
```

### Graph

```{r implicit overview}
local({
  callsite_color <- "darkblue" #"#ED6559"
  declaration_color <-"darkgoldenrod1"    #"#4C5D7C"
    
  # the trick with superposition is to do the log10 scaling manually
  corpus_implicitness_overview <- 
    corpus_noncat %>%
    mutate(
      implicit_declarations=if_else(implicit_declarations > 0, log10(implicit_declarations), 0)
    )
  
  # up to which part of the implicit local declarations can this graph overlap
  cs_ds_opverlap <- 1
  cs_end <- max(corpus_implicitness_overview$implicit_declarations)
  # this is the height of the overlap which is equal to 100% of implicit callsites ration
  cs_height <- cs_end - 10^(log10(cs_end) - log10(cs_end) * cs_ds_opverlap)
  
  # the implicit callsites ratio will be plotted using segments
  # for this we need to compute y and yend (x and xend are the same - project_id)
  corpus_implicitness_overview <- 
    corpus_implicitness_overview %>%
    transmute(
      project_id,
      ds=implicit_declarations,
      cs=implicit_callsites/callsites,
      cs_start=cs_end - cs_height * cs
    ) %>%
    mutate(
      project_id=forcats::fct_reorder(project_id, ds)
    )
  
  pri_breaks <- seq(cs_end, cs_end*(1-cs_ds_opverlap), length.out = 5)
  pri_labels <- seq(0, 100, length.out = length(pri_breaks)) %>% str_c("%")
  sec_breaks <- c(0:as.integer(cs_end), cs_end)
  sec_labels <- c("0", fmt(10^sec_breaks[-1]))
  
  corpus_implicitness_overview %>%
    ggplot(aes(x=project_id, y=ds)) + 
    
    geom_segment(
      aes(xend=project_id, y=cs_start, yend=cs_end),
      color=callsite_color, alpha=.5
    ) +
    geom_bar(width=1, stat="identity",fill=declaration_color, alpha=.7) +
    
    theme(
      axis.ticks.x=element_blank(),
      axis.ticks.y=element_line(),
      panel.grid.major.x=element_blank(), 
      panel.grid.minor.x=element_blank(),
      panel.grid.major.y=element_line(),
      panel.grid.minor.y=element_blank(),
      axis.text.x=element_blank(),
      axis.text.y=element_text(color = "grey20", size = 10),
      axis.title.x=element_text( size = 11),
      axis.title.y=element_text( size = 11)
    ) + 
    
    scale_y_continuous(
      breaks=pri_breaks,
      labels=pri_labels,
      name="Ratio of implicit calls",
      sec.axis=sec_axis(
        trans=~.,
        name="Number of implicit declarations (log)",
        breaks=sec_breaks, 
        labels=sec_labels
      ) 
    ) +
    
    labs(x="Projects")
})
```

```{r save implicits overview plot}
ggsave(OUT_IMPLICITS_OVERVIEW_PDF)
```

### Summary

```{r implicits overview}
n_implicit_declarations <- sum(corpus_noncat$implicit_declarations)

n_callsites          <- sum(corpus_noncat$callsites)
n_explicit_callsites <- sum(corpus_noncat$explicit_callsites)
n_implicit_callsites <- sum(corpus_noncat$implicit_callsites)

stopifnot(n_callsites == n_explicit_callsites + n_implicit_callsites)

n_test_explicit_callsites <- sum(corpus_noncat$test_explicit_callsites)
n_test_implicit_callsites <- sum(corpus_noncat$test_implicit_callsites)
n_test_callsites          <- n_test_explicit_callsites + n_test_implicit_callsites  

stopifnot(n_test_callsites == n_test_explicit_callsites + n_test_implicit_callsites)

projects_using_implicits <- filter(corpus_noncat, implicit_callsites > 0)
projects_defining_implicits <- filter(corpus_noncat, implicit_declarations > 0)
declarations_local_external <- distinct(declarations_all, def_library, declaration_id)

declarations_local_public  <- filter(declarations_local, !def_is_access_specified | def_is_public)
declarations_local_in_main <- filter(declarations_local, !def_is_in_test)
declarations_local_in_test <- filter(declarations_local, def_is_in_test)

overview_table(
  r("implicit local and extenal declarations", declarations_local_external),
  r("implicit declarations",             declarations_local),
  r("implicit declarations public",      declarations_local_public),
  r("implicit declarations public pct",  ratio(declarations_local_public, declarations_local)),
  r("implicit declarations in main",     declarations_local_in_main),
  r("implicit declarations in main pct", ratio(declarations_local_in_main, declarations_local)),
  r("implicit declarations in test",     declarations_local_in_test),
  r("implicit declarations in test pct", ratio(declarations_local_in_test, declarations_local)),
  r("local implicit declarations pct", ratio(declarations_local, declarations_local_external)),
  
  r("call sites",              n_callsites),
  r("explicit call sites",     n_explicit_callsites),
  r("implicit call sites",     n_implicit_callsites),
  r("implicit call sites pct", percent(n_implicit_callsites/n_callsites)),
  
  r("test call sites",              n_test_callsites),
  r("test explicit call sites",     n_test_explicit_callsites),
  r("test implicit call sites",     n_test_implicit_callsites),
  r("test implicit call sites pct", percent(n_test_implicit_callsites/n_test_callsites)),
  
  r("projects using implicits",        projects_using_implicits),
  r("projects defining implicits",     projects_defining_implicits),
  r("projects using implicits pct",    ratio(projects_using_implicits, corpus_noncat)),
  r("projects defining implicits pct", ratio(projects_defining_implicits, corpus_noncat))
)
```

## Other platforms

```{r}
projects_other_platform <- 
  declarations_all %>%
  filter(def_is_js | def_is_native) %>%
  count(project_id) %>% 
  select(project_id) %>%
  semi_join(corpus_noncat, ., by="project_id")

n_projects_jvm    <- nrow(count(filter(declarations_all, def_is_jvm), project_id))
n_projects_js     <- nrow(count(filter(declarations_all, def_is_js), project_id))
n_projects_native <- nrow(count(filter(declarations_all, def_is_native), project_id))

overview_table(
  overview_projects("projects targeting other platform", projects_other_platform),
  r("projects targeting JVM",    n_projects_jvm),
  r("projects targeting JS",     n_projects_js),
  r("projects targeting native", n_projects_native)
)
```

## Analyzing Implicits Usage (Section 5)

### Patterns oveview

```{r aux pattern functions}
pattern_summary <- function(pattern, ds, cs) {
  ds_stat <- summarise_count_per_category(ds, def_is_in_test, "declarations")
  cs_stat <- summarise_count_per_category(cs, is_in_test, "callsites")
  
  corpus_cat %>%
    select(project_id, cat) %>%
    left_join(ds_stat, by=c("project_id", "cat")) %>%
    left_join(cs_stat, by=c("project_id", "cat")) %>%
    mutate_at(vars(declarations, callsites), ~replace_na(., 0)) %>%
    mutate(pattern=pattern)
}

match_callsites <- function(ds) {
  semi_join(callsites_all, ds, by=c("mid", "declaration_id"))
}

match_methods_using_parameter <- function(ds, ps) {
  semi_join(ds, ps, by=c("mid", "declaration_id"))
}

patterns_human_name <- function(x) {
  case_when(
    x=="ALL" ~ "Overview",
    x=="BIC" ~ "Bidirectional Conversion",
    x=="CTX" ~ "Context",
    x=="EM"  ~ "Extension Methods",
    x=="ESM" ~ "Extension Syntax Methos",
    x=="IC"  ~ "Implicit Conversions",
    x=="IP"  ~ "Implicit Parameters",
    x=="LTI" ~ "Late Trait Implementation",
    x=="TC"  ~ "Type Classess",
    x=="TP"  ~ "Type Proofs",
    x=="UIC" ~ "Unrelated Conversions"
  )
}
```

#### Overview (ALL)

```{r pattern all}
pattern_all_ds <- declarations_local
pattern_all_cs <- callsites_all
pattern_all <- pattern_summary("ALL", declarations_local, callsites_all)
```

#### Implicit Parameters (IP)

```{r pattern implicit parameters}
pattern_implicit_parameters_ds <- filter(declarations_local, def_kind=="DEF", num_implicit_parameters > 0)
pattern_implicit_parameters_cs <- filter(callsites_all, def_kind=="DEF", num_implicit_arguments > 0)
pattern_implicit_parameters <- pattern_summary("IP", pattern_implicit_parameters_ds, pattern_implicit_parameters_cs)
```

#### Implicit Conversions (IC)

```{r pattern implicit conversions}
pattern_implicit_conversions_ds <- conversions_local
pattern_implicit_conversions_cs <- match_callsites(conversions_all)
pattern_implicit_conversions <- pattern_summary("IC", pattern_implicit_conversions_ds, pattern_implicit_conversions_cs)
```

```{r check implicit conversions}
# no duplicates
stopifnot(nrow(pattern_implicit_conversions_ds %>% count(mid, declaration_id) %>% filter(n > 1)) == 0)
```


#### Late Trait Implementation (LTI)

```{r pattern late trait implementation}
match_late_trait <- function(df) {
  filter(df, def_kind=="DEF", to_is_trait)
}

pattern_late_trait_ds <- match_late_trait(conversions_local)
pattern_late_trait_cs <- match_late_trait(conversions_all) %>% match_callsites()
pattern_late_trait <- pattern_summary("LTI", pattern_late_trait_ds, pattern_late_trait_cs)
```

#### Extension Methods (EM)

```{r pattern extensions methods}
match_extension_methods <- function(df) {
  filter(
    df, 
    def_kind=="DEF", 
    # implicit class
    def_is_companion |
      # implicit def that is defined in the same file as the target of the conversion
      (to_location_path==def_location_path & to_location_uri==def_location_uri)
  )
}

pattern_extension_methods_ds <- match_extension_methods(conversions_local)
pattern_extension_methods_cs <- match_extension_methods(conversions_all) %>% match_callsites()
pattern_extension_methods <- pattern_summary("EM", pattern_extension_methods_ds, pattern_extension_methods_cs)
```

#### Type Classes (TC)

```{r type class parameters}
match_type_class_parameter <- function(ps) {
  filter(ps, num_type_argument_refs >= 1, resolved_type_kind != "TYPE_PARAMETER")
}

parameters_all_type_classes   <- match_type_class_parameter(parameters_all)
parameters_local_type_classes <- match_type_class_parameter(parameters_local)
```

```{r pattern type class methods}
pattern_type_class_ds <- match_methods_using_parameter(declarations_local, parameters_local_type_classes)
pattern_type_class_cs <- match_methods_using_parameter(declarations_all, parameters_all_type_classes) %>% match_callsites()
pattern_type_class <- pattern_summary("TC", pattern_type_class_ds, pattern_type_class_cs)
```

#### Bidirectional Implicit Conversion (BIC)

scala/collection/convert/WrapAsJava#`deprecated asJavaCollection`().
from: scala/collection/Iterable#[scala/collection/convert/WrapAsJava#`deprecated asJavaCollection`().[A]]
to:        java/util/Collection#[scala/collection/convert/WrapAsJava#`deprecated asJavaCollection`().[A]]

from: scala/collection/Iterable#[[A]]
to:        java/util/Collection#[[A]]

scala/collection/convert/WrapAsScala#`deprecated collectionAsScalaIterable`().
from:      java/util/Collection#[scala/collection/convert/WrapAsScala#`deprecated collectionAsScalaIterable`().[A]]
to:   scala/collection/Iterable#[scala/collection/convert/WrapAsScala#`deprecated collectionAsScalaIterable`().[A]]

from:      java/util/Collection#[[A]]
to:   scala/collection/Iterable#[[A]]


```{r pattern bi-directional implicit conversion}
match_bi_directional_conversions <- function(df) {
  df <-
    df %>%
    mutate(
      from=str_replace(from, fixed(declaration_id), ""),
      to=str_replace(to, fixed(declaration_id), "")
    )
  
  from <-
    df %>%
    select_at(
      vars(
        pid, mid, project_id, declaration_id, 
        from, to, starts_with("from_"), 
        def_group_id, def_artifact_id, def_location_path, def_location_uri, def_is_in_test, def_github_url)
      )
  
  to <-
    df %>%
    select_at(
      vars(
        pid, mid, project_id, declaration_id, 
        from, to, starts_with("to_"), 
        def_group_id, def_artifact_id, def_location_path, def_location_uri, def_is_in_test, def_github_url)
      )
  
  # TODO: use paths
  # TODO: use compilation units
  
  left_join(
    from, 
    to,
    by=c("from"="to", "to"="from")
  ) %>%
    filter(
      def_group_id.x      == def_group_id.y,
      def_artifact_id.x   == def_artifact_id.y
    ) %>%
    select_at(vars(-ends_with(".y"))) %>%
    rename_at(vars(ends_with(".x")), ~str_replace(., ".x", ""))
}

pattern_bi_directional_ds <- match_bi_directional_conversions(conversions_local)
pattern_bi_directional_cs <- match_bi_directional_conversions(conversions_all) %>% match_callsites()
pattern_bi_directional <- pattern_summary("BIC", pattern_bi_directional_ds, pattern_bi_directional_cs)
```

```{r}
# should match scala deprecated java converters
stopifnot(nrow(filter(pattern_bi_directional_ds, declaration_id=="scala/collection/convert/WrapAsScala#`deprecated collectionAsScalaIterable`().")) != 0)
stopifnot(nrow(filter(pattern_bi_directional_ds, declaration_id=="scala/collection/convert/WrapAsJava#`deprecated asJavaCollection`().")) != 0)
```

#### Type Proofs (TP)

```{r pattern type proofs}
TYPE_PROOFS_TYPE_IDS = c("=:=", "<:<", "=>")
match_type_proofs_parameters <- function(ps) {
  map_dfr(TYPE_PROOFS_TYPE_IDS, ~filter(ps, str_detect(resolved_type_id, .)))
}

parameters_local_type_proofs <- match_type_proofs_parameters(parameters_local)
parameters_all_type_proofs <- match_type_proofs_parameters(parameters_all)

pattern_type_proofs_ds <- match_methods_using_parameter(declarations_local, parameters_local_type_proofs)
pattern_type_proofs_cs <- match_methods_using_parameter(declarations_all, parameters_all_type_proofs) %>% match_callsites()
pattern_type_proofs <- pattern_summary("TP", pattern_type_proofs_ds, pattern_type_proofs_cs)
```

#### Extension Syntax Methods (ESM)

```{r pattern extension syntax methods}
match_syntax <- function(ds, ps) {
  match_methods_using_parameter(ds, ps) %>%
    filter(def_is_implicit)
}

parameters_local_non_type_proofs <- anti_join(parameters_local, parameters_local_type_proofs, by=c("mid", "declaration_id"))
parameters_all_non_type_proofs <-   anti_join(parameters_all, parameters_all_type_proofs, by=c("mid", "declaration_id"))

pattern_syntax_ds <- match_syntax(declarations_local, parameters_local_non_type_proofs)
pattern_syntax_cs <- match_syntax(declarations_all, parameters_all_non_type_proofs) %>% match_callsites()
pattern_syntax <- pattern_summary("ESM", pattern_syntax_ds, pattern_syntax_cs)
```

#### Context (CTX)

```{r pattern context}
match_context_parameter <- function(ps) {
  filter(ps, num_type_argument_refs == 0, resolved_type_kind != "TYPE_PARAMETER")
}

parameters_local_context <- match_context_parameter(parameters_local)
parameters_all_context   <- match_context_parameter(parameters_all)

pattern_context_ds <- match_methods_using_parameter(declarations_local, parameters_local_context)
pattern_context_cs <- match_methods_using_parameter(declarations_all, parameters_all_context) %>% match_callsites()
pattern_context <- pattern_summary("CTX", pattern_context_ds, pattern_context_cs)
```

#### Unrelated Conversions (UIC)

Unrelated conversions are public, top-level definitions (reachable from outside
of the compilation unit) defined outside either from or to compilation units.

```{r pattern unrelated conversions}
match_unrelated_conversion <- function(df, compilation_units) {
  top_level_public_defs <-
    df %>%
    filter(
      def_kind == "DEF",
      !def_is_companion,
      !is_block_local, 
      !def_is_access_specified | def_is_public
    )
  
  if (compilation_units) {
    top_level_public_defs %>%
    filter(
      def_compilation_unit != from_compilation_unit,
      def_compilation_unit != to_compilation_unit
    )
  } else {
    top_level_public_defs %>%
    filter(
      def_group_id != from_group_id,
      def_group_id != to_group_id,
      def_artifact_id != from_artifact_id,
      def_artifact_id != to_artifact_id
    )
  }
}

unrelated_conversions_cu_ds  <- match_unrelated_conversion(conversions_local, TRUE)
unrelated_conversions_lib_ds <- match_unrelated_conversion(conversions_local, FALSE)

pattern_unrelated_conversions_ds <- unrelated_conversions_cu_ds
pattern_unrelated_conversions_cs <- match_unrelated_conversion(conversions_all, TRUE) %>% match_callsites()
pattern_unrelated_conversions <- pattern_summary("UIC", pattern_unrelated_conversions_ds, pattern_unrelated_conversions_cs)
```

#### Summary

```{r aux patterns overview}
compute_pattern_overview <- function(patterns) {
  corpus_cat_overview <-
    corpus_cat %>%
    group_by(cat) %>%
    summarise(
      projects=n(),
      all_implicit_callsites=sum(implicit_callsites),
      all_explicit_callsites=sum(explicit_callsites),
      all_callsites=sum(callsites),
      all_implicit_declarations=sum(implicit_declarations)
    )

  stopifnot(mutate(corpus_cat_overview, check=all_callsites - all_explicit_callsites - all_implicit_callsites) %>% filter(check!=0) %>% nrow() == 0)

  patterns_overview <-
    patterns %>%
    group_by(pattern, cat) %>%
    summarise(
      projects_declaring=sum(declarations > 0),
      projects_using=sum(callsites > 0),
      declarations=sum(declarations),
      callsites=sum(callsites)
    ) %>%
    ungroup() %>%
    left_join(
      select(corpus_cat_overview, cat, projects), 
      by="cat"
    ) %>%
    mutate(
      projects_declaring_pct=projects_declaring/projects,
      projects_using_pct=projects_using/projects
    ) %>%
    select(-projects)

  patterns_overview_sums <-
    patterns_overview %>%
    group_by(pattern) %>%
    summarise_at(vars(declarations, callsites), sum) %>%
    rename_at(vars(declarations, callsites), ~str_c("all_", .))

  patterns_overview %>%
  left_join(patterns_overview_sums, by="pattern") %>%
  mutate(
    declarations_pct=declarations/all_declarations,
    callsites_pct=callsites/all_callsites
  ) %>%
  select(-all_declarations, -all_callsites)
}

compute_pattern_overview_all_row <- function(patterns) {
  patterns %>%
  group_by(pattern) %>%
  summarise(
    projects_declaring=length(unique(project_id[declarations > 0])),
    projects_using=length(unique(project_id[callsites > 0])),
    declarations=sum(declarations),
    callsites=sum(callsites)
  ) %>% mutate(
    cat="all",
    projects_declaring_pct=projects_declaring/nrow(corpus_noncat),
    projects_using_pct=projects_using/nrow(corpus_noncat),
    declarations_pct=declarations/n_implicit_declarations,
    callsites_pct=callsites/n_implicit_callsites 
  )
}
```

```{r pattern overview test, eval=F}
p <- tribble(
  ~project_id, ~cat,   ~declarations, ~callsites, ~pattern,
  "A",         "test", 1            , 5         , "x",
  "A",         "lib",  10           , 10        , "x",
  "A",         "test", 2            , 3         , "y",
  "B",         "lib" , 3            , 4         , "y",
  "C",         "lib" , 1            , 1         , "y",
)

compute_pattern_overview(p)
compute_pattern_overview_all_row(p)
```

```{r aux compute pattern tables}
.fmt.custom_format <- function(x) {
  format <- attr(x, "format")
  sprintf(format, x)
}

custom_format <- function(x, format) {
  class(x) <- "custom_format"
  attr(x, "format") <- format
  x
}

compute_overview_table <- function(df) {
  df %>%
  mutate_if(is.numeric, oom) %>%
  mutate_at(vars(ends_with("_pct")), ~custom_format(.*100, "%02.0f%%")) %>%
  mutate_all(fmt) %>%
  transmute(
    pattern,
    cat,
    callsites=str_c(callsites, " (", callsites_pct, ", ", projects_using_pct, ")"),
    declarations=str_c(declarations, " (", declarations_pct, ", ", projects_declaring_pct, ")")
  ) %>%
  gather(variable, value, -(pattern:cat)) %>%
  unite(temp, cat, variable) %>%
  spread(temp, value) %>%
  select(
    pattern,
    app_small_declarations,
    app_big_declarations,
    lib_declarations, 
    test_declarations, 
    app_small_callsites,  
    app_big_callsites,
    lib_callsites,           
    test_callsites
  )
}

compute_overview_table_declarations <- function(df, pattern_column="Pattern") {
  df %>%
  transmute(
    !!pattern_column := patterns_human_name(pattern),
    `Small Apps`=app_small_declarations,
    `Large Apps`=app_big_declarations,
    `Libraries`=lib_declarations, 
    `Tests`=test_declarations
  )
}

compute_overview_table_callsites <- function(df, pattern_column="Pattern") {
  df %>%
  transmute(
    !!pattern_column := patterns_human_name(pattern),
    `Small Apps`=app_small_callsites,
    `Large Apps`=app_big_callsites,
    `Libraries`=lib_callsites, 
    `Tests`=test_callsites
  )
}

print_pattern_overview <- function(df) {
  df %>% 
  mutate_at(vars(ends_with("_pct")), percent) %>%
  mutate_all(fmt) %>%
  my_datatable()
}
```

```{r aux save patterns}
save_pattern_tables <- function(df, pattern_names, ds_filename, cs_filename, ...) {
  save_table <- function(df, fname) {
    df %>%
    xtable::xtable(align="llrrrr") %>%
    print(
      floating=F,
      file=fname,
      include.rownames=F
    )
  }

  table <-
    df %>%
    filter(pattern %in% pattern_names) %>%
    mutate(pattern=factor(pattern, levels=pattern_names, ordered = T)) %>%
    arrange(pattern)
  
  table_ds <- compute_overview_table_declarations(table, ...)
  table_cs <- compute_overview_table_callsites(table, ...)
  
  save_table(table_ds, ds_filename)
  save_table(table_cs, cs_filename)
  
  table
}
```

```{r patterns all}
patterns_all <- bind_rows(
  # overview
  pattern_all,
  pattern_implicit_conversions,
  pattern_implicit_parameters,
  # idioms
  pattern_late_trait,
  pattern_extension_methods,
  pattern_type_class,
  pattern_syntax,
  pattern_type_proofs,
  pattern_context,
  pattern_unrelated_conversions,
  pattern_bi_directional,
)

patterns_all_overview <- compute_pattern_overview(patterns_all)
patterns_all_overview_all_row <- compute_pattern_overview_all_row(patterns_all)

patterns_all_overview %>%
  mutate(pattern=patterns_human_name(pattern)) %>%
  write_csv(OUT_PATTERNS_CSV)

patterns_all_table <- compute_overview_table(patterns_all_overview)

print_pattern_overview(patterns_all_overview)
```

```{r save overview patterns}
save_pattern_tables(patterns_all_table, c("ALL", "IC", "IP"), OUT_PATTERNS_OVERVIEW_DECLARATIONS_TEX, OUT_PATTERNS_OVERVIEW_CALLSITES_TEX, pattern_column=" ")
```

```{r save patterns}
save_pattern_tables(patterns_all_table, c("LTI", "EM", "TC", "ESM", "TP", "CTX", "UIC", "BIC"), OUT_PATTERNS_DECLARATIONS_TEX, OUT_PATTERNS_CALLSITES_TEX)
```

```{r a graphical overview}
patterns_all_overview %>%
  mutate(pattern=patterns_human_name(pattern)) %>%
  select_at(vars(pattern, cat, ends_with("_pct"))) %>%
  gather(variable, value, -(pattern:cat)) %>% 
  ggplot(aes(x=cat,y=value,fill=cat)) + geom_bar(stat="identity") + facet_grid(pattern~variable)
```

```{r}
patterns_overview <- bind_rows(
  patterns_all_overview,
  patterns_all_overview_all_row
)

pattern_info <- function(pattern, category, overview=patterns_overview) {
  ctg <- match.arg(category, overview$cat)
  ptn <- match.arg(pattern, overview$pattern)

  filter(overview, cat==ctg, pattern==ptn) %>%
    mutate_at(vars(ends_with("_pct")), percent) %>%
    as.list()
}
```

```{r}
stopifnot(pattern_info("ALL", "all")$declarations_pct == 100)
stopifnot(pattern_info("ALL", "all")$callsites_pct == 100)
```

```{r aux pattern overview}
overview_pattern <- function(info) {
  pattern <- info$pattern
  category <- info$cat
  
  overview(
    r(str_c(pattern, " ", category, " projects using"),         info$projects_using),
    r(str_c(pattern, " ", category, " projects using pct"),     info$projects_using_pct),
    r(str_c(pattern, " ", category, " projects declaring"),     info$projects_declaring),
    r(str_c(pattern, " ", category, " projects declaring pct"), info$projects_declaring_pct),
    
    r(str_c(pattern, " ", category, " callsites"),     info$callsites),
    r(str_c(pattern, " ", category, " callsites pct"), info$callsites_pct),
    
    r(str_c(pattern, " ", category, " declarations"),     info$declarations),
    r(str_c(pattern, " ", category, " declarations pct"), info$declarations_pct)
  )
}
```

### Implicit Conversion (Section 5.1)

Excluded uTest ("^com\\.lihaoyi:utest.*") as it only defines 5 conversions. It is using macros.

```{r test and scala libraries setup}
TEST_LIBS <- c(
  "^org\\.specs2:.*",
  "^org\\.scalatest:.*",
  "^org\\.scalactic:.*"
)

TEST_LIBS_DF <-
  count(declarations_all, def_library) %>%
    filter(str_detect_multiple(def_library, TEST_LIBS)) %>%
    select(-n)

SCALA_LIB <- "org\\.scala-lang:scala-library.*"
SCALA_LIB_DF <-
  count(declarations_all, def_library) %>%
    filter(str_detect_multiple(def_library, SCALA_LIB)) %>%
    select(-n)

SCALA_and_TEST_LIB_DF <-
  bind_rows(
    SCALA_LIB_DF,
    TEST_LIBS_DF
  )
```

```{r aux top n projects}
top_n_projects <- function(df_ds, df_cs, N=10) {
  stopifnot(c("project_id", "n") %in% names(df_ds))
  
  format_df <- function(df, suffix) {
    name_column <- str_c("name_", suffix)
    n_column <- str_c("n_", suffix)
    
    top_n(df, N, n) %>%
    left_join(
      select(corpus_noncat, project_id, origin, gh_stars, scala_code=main_scala_code),
      by="project_id"
    ) %>%
    arrange(desc(n)) %>%
    mutate(
      ord=1:n(),
      name=str_replace(project_id, "--", "/"),
      name=xtable::sanitize(name),
      gh_stars=fmt(oom(gh_stars), digits=0),
      scala_code=fmt(oom(scala_code), digits=0),
      name=str_c("\\href{https://github.com/", name, "/}{", name, "} (", gh_stars, ", ", scala_code, ")"),
      n=fmt(oom(n), digits=0)
    ) %>%
      transmute(
        !!name_column := name,
        !!n_column := n,
        ord
      )
  }
  
  ds <- format_df(df_ds, "ds")
  cs <- format_df(df_cs, "cs")
  df <- left_join(ds, cs, by="ord")
  df %>% 
    select(
      -ord,
      `Project`=name_ds,
      `Project `=name_cs, # ugly hack
      `Declarations`=n_ds,
      `Callsites`=n_cs,
    )
}

save_top_n_projects <- function(df_ds, df_cs, fname) {
  df <- top_n_projects(df_ds, df_cs) 
  
  print(df)
  
  df %>%
  xtable::xtable(align="llrlr") %>%
  print(
    floating=F,
    file=fname,
    include.rownames=F,
    sanitize.text.function=identity
  )
}
```

```{r implicit conversion data}
conversion_cs_from_scala <- filter(pattern_implicit_conversions_cs, def_is_from_scala)
conversion_cs_from_scala_main <- filter(pattern_implicit_conversions_cs, def_is_from_scala, !is_in_test)
# TODO: explain whe cannot we use def_is_from_scala
conversion_ds_from_scala <- semi_join(pattern_implicit_conversions_ds, SCALA_LIB_DF, by="def_library")
conversion_cs_from_testlib <- semi_join(pattern_implicit_conversions_cs, TEST_LIBS_DF, by="def_library")

IC_all <- pattern_info("IC", "all")
IC_test <- pattern_info("IC", "test")

# TODO: this should come from the pattern - we just need a way how to get rid of tests
IC_ds_per_project <- count(pattern_implicit_conversions_ds, project_id)
IC_cs_per_project <- count(pattern_implicit_conversions_cs, project_id)
IC_declaration <- count(pattern_implicit_conversions_cs, def_library, declaration_id)

IC_callsites_platforms <- 
  count(pattern_implicit_conversions_cs, def_platform) %>% 
  spread(def_platform, n) %>%
  mutate(
    js_pct=js/n_projects_js,
    jvm_pct=jvm/n_projects_jvm,
    native_pct=native/n_projects_native
  )

IC_declarations_from_scala_and_testlib <-
  semi_join(pattern_implicit_conversions_ds, SCALA_and_TEST_LIB_DF, by="def_library") %>%
  count(def_group_id)
```

```{r implicit conversion report}
overview_table(
  overview_pattern(IC_all),
  overview_pattern(IC_test),
  
  r("IC callsites from scala pct",              percent(nrow(conversion_cs_from_scala)      /  IC_all$callsites)),
  r("IC callsites from scala in main pct",      percent(nrow(conversion_cs_from_scala_main) / (IC_all$callsites - IC_test$callsites))),
  r("IC callsites from test libraries pct",     percent(nrow(conversion_cs_from_testlib)    /  IC_test$callsites)),
  r("IC callsites from local declarations pct", ratio(filter(pattern_implicit_conversions_cs, !def_is_in_dependency), pattern_implicit_conversions_cs)),
  
  r("IC declarations mean",   mean(IC_ds_per_project$n)),
  r("IC declarations sd",     sd(IC_ds_per_project$n)),
  r("IC declarations median", median(IC_ds_per_project$n)),
  
  r("IC declarations sd without slinky", sd(filter(IC_ds_per_project, project_id!="shadaj--slinky")$n)),
  
  r("IC used in js vs jvm", IC_callsites_platforms$js_pct/IC_callsites_platforms$jvm_pct),
  
  r("IC in scala stdlib", conversion_ds_from_scala),
  r("IC in scala", filter(IC_ds_per_project, project_id=="scala--scala")$n),
  r("IC in scalatest", filter(IC_ds_per_project, project_id=="scalatest--scalatest")$n),
  r("IC in spec", filter(IC_ds_per_project, project_id=="etorreborre--specs2")$n),
  r("IC in utest", filter(IC_ds_per_project, project_id=="lihaoyi--utest")$n),
  r("IC in scalaz", filter(IC_ds_per_project, project_id=="scalaz--scalaz")$n),
  r("IC in cats", filter(IC_ds_per_project, project_id=="typelevel--cats")$n),
  r("IC in slinky", filter(IC_ds_per_project, project_id=="shadaj--slinky")$n),
)

save_top_n_projects(IC_ds_per_project, IC_cs_per_project, path(output_dir, "IC-top-projects.tex"))
```

#### Exploration

```{r top use of declarations from non-scala and non-testlib}
IC_declaration_without_scalalib_testlib <-
  IC_declaration %>%
  anti_join(
    bind_rows(TEST_LIBS_DF, SCALA_LIB_DF), 
    by="def_library"
  )

arrange(IC_declaration_without_scalalib_testlib, desc(n))
```

```{r top use of declarations from scala and testlib}
IC_declaration_from_scalalib_testlib <-
  IC_declaration %>%
  semi_join(
    bind_rows(TEST_LIBS_DF, SCALA_LIB_DF), 
    by="def_library"
  )

arrange(IC_declaration_from_scalalib_testlib, desc(n))
```

```{r top use of declarations from scala}
IC_declaration_from_scalalib <-
  IC_declaration %>%
  semi_join(
    SCALA_LIB_DF, 
    by="def_library"
  )

arrange(IC_declaration_from_scalalib, desc(n))
```

#### Slink

```{r}
slinky_in_corpus <-
  filter(pattern_implicit_conversions_cs, def_library=="me.shadaj:slinky-web:js") %>% 
    count(project_id, declaration_id) %>%
    count(project_id) %>%
    left_join(select(corpus_noncat, project_id, scala_code, gh_stars), by="project_id")

overview_table(
  r("IC slinky use", sum(slinky_in_corpus$n)),
  r("IC slinky use projects", nrow(slinky_in_corpus)),
  r("IC slinky use projects code", sum(slinky_in_corpus$scala_code)),
)
```

#### TODO: From / To conversions

```{r eval=F}
top_from <- pattern_implicit_conversions_ds %>% count(from) %>% arrange(desc(n))

semi_join(
  pattern_implicit_conversions_ds,
  top_n(top_from, 1),
  by="from"
)

top_to <- pattern_implicit_conversions_ds %>% count(to) %>% arrange(desc(n)) %>% filter(!str_detect(to, "slinky"))

pattern_implicit_conversions_ds %>% 
  filter(from=="java/lang/String#") %>% 
  count(to, project_id) %>%
  arrange(desc(n)) %>%
  count(to) %>% 
  arrange(desc(n))

pattern_implicit_conversions_ds %>% count(from, to) %>% arrange(desc(n)) %>% print(n=100)
```

#### TODO: Conditional conversions

#### TODO: Collection conversions

#### Functional value conversions

```{r}
match_fun_conversion <- function(df) {
  filter(df, def_kind != "DEF")
}

IC_fun_ds <- match_fun_conversion(conversions_local)
IC_fun_cs <- match_fun_conversion(conversions_all) %>% match_callsites()

IC_fun <- pattern_summary("ICfun", IC_fun_ds, IC_fun_cs)
IC_fun_sum <- compute_pattern_overview(IC_fun)
IC_fun_all_row <- compute_pattern_overview_all_row(IC_fun)

print_pattern_overview(IC_fun_all_row)
```

```{r}
IC_java_to_java_ds %>% select(from, from_group_id, to, to_group_id)
```

```{r}
overview_table(
  overview_pattern(pattern_info("ICfun", "all", IC_fun_all_row)),
  overview_pattern(pattern_info("ICfun", "test", IC_fun_sum))
)
```

### Implicit Parameter (Section 5.2)

#### Ratio of call sites that are implicits

```{r}
select(corpus_cat, project_id, cat, implicit_callsites, callsites) %>%
  mutate(
    r=implicit_callsites/callsites,
    cat=cat_to_fct(cat)
  ) %>%
  ggplot(aes(x=cat, y=r, fill=cat, color=cat)) + 
  geom_boxplot(width=.5, alpha=.7, lwd=.2, outlier.size = 0, outlier.stroke=0) +
#  geom_flat_violin(width=.5, alpha=.7, lwd=.2) +
  geom_dotplot(
    binaxis="y", 
    dotsize=0.08, 
    stackdir="down",
    stackratio=1,
    binwidth=0.005, 
    position=position_nudge(-0.025),
    alpha=.7
  ) +
  scale_fill_wsj(labels=fmt_categories) +
  scale_color_wsj(labels=fmt_categories) +
  scale_x_discrete(labels=fmt_categories_short) +
  scale_y_continuous(labels=scales::percent, limits=c(0, .75)) +
  guides(fill=F, color=F) +
  labs(
    y="Ratio of implicit call sites"
  ) +
  theme(
    aspect.ratio = 2,
    axis.title.x = element_blank(),
    axis.text.x = element_text(size=10)
  )
```

```{r}
ggsave(OUT_IMPLICIT_CALLSITES_RATIO_PDF)
```

#### Location of implicit declarations

```{r}
empty_declarations <- filter(pattern_all_cs, FALSE)
def_local    <- pattern_summary("local",    empty_declarations, filter(callsites_all, !def_is_in_dependency))
def_external <- pattern_summary("external", empty_declarations, filter(callsites_all, def_is_in_dependency, !def_is_from_scala))
def_scala    <- pattern_summary("scala",    empty_declarations, filter(callsites_all, def_is_in_dependency, def_is_from_scala))
def_all <-
  bind_rows(
    def_local,
    def_external,
    def_scala
  )

stopifnot(sum(def_all$callsites) == nrow(callsites_all))

defs_overview <- 
  def_all %>%
  left_join(
    select(corpus_cat, project_id, cat, implicit_callsites),
    by=c("project_id", "cat")
  ) %>%
  mutate(
    callsites_pct=callsites/implicit_callsites
  ) %>%
  select(project_id, pattern, cat, callsites_pct)
```

```{r}
defs_overview %>%
  mutate(cat=cat_to_fct(cat)) %>%
  ggplot(aes(x=pattern, y=callsites_pct, color=cat)) + 
  geom_boxplot(aes(fill=cat), width=.5, alpha=.7, lwd=.2, outlier.size=0, outlier.stroke=0, position=position_dodge(.8)) +
#  geom_flat_violin(width=.5, alpha=.7, lwd=.2, trim = T, scale="width", position = position_dodge(.8), draw_quantiles=1) +
  geom_dotplot(
    binaxis="y",
    dotsize=0.08,
    stackdir="down",
    stackratio=1,
    binwidth=0.005,
    position = position_dodge(.8),
    alpha=.7
  ) +
  scale_fill_wsj(labels=fmt_categories_short) +
  scale_x_discrete(labels=c("external"="External dependencies", "local"="Project local", "scala"="Scala standard library")) +
  scale_color_wsj() +
  scale_y_continuous(labels=scales::percent) +
  theme(
    axis.title.x = element_blank(),
    legend.position = c(.5, 0.8),
    legend.box.background = element_rect(fill="white", size=0.1),
    axis.text.x = element_text(size=10)
  ) +
  guides(color=F) +
  labs(fill="Category", y="Ratio of implicit calls")
```

```{r}
ggsave(OUT_CALLSITES_LOCATION_RATIO_PDF)
```

#### Text

```{r}
nrow(declarations_local)/2
n_all_stars <- sum(corpus_noncat$gh_stars)
n_all_code <- sum(corpus_noncat$scala_code)
top200_declarations <-
  corpus_noncat %>%
  select(project_id, cat, implicit_declarations, gh_stars, scala_code) %>%
  top_n(200, implicit_declarations) %>%
  arrange(desc(implicit_declarations))

top200_sums <- summarise_all(top200_declarations, sum)
top200_cats <- count(top200_declarations, cat) %>% spread(cat, n)
```

```{r}
overview_table(
  r("IP apps in top projects", top200_cats$app_big/200),
)
```

```{r}
filter(pattern_implicit_parameters_cs, def_is_from_scala) %>% 
  count(declaration_id) %>%
  arrange(desc(n))
```

```{r}
filter(parameters_all, type_group_id=="org.scala-lang", type_artifact_id=="scala-library") %>% 
  count(resolved_type_id) %>%
  arrange(desc(n))
```

```{r}
match_parameter_id <- function(regex) {
  filter(parameters_all, str_detect(resolved_type_id, regex))
}

projects_using <- function(name, ds) {
  cs <- match_callsites(ds)

  p <- pattern_summary(name, empty_declarations, cs)
  
  bind_rows(
    compute_pattern_overview(p),
    compute_pattern_overview_all_row(p)
  ) %>%
    select(
      pattern,
      cat,
      projects_using,
      callsites, 
      projects_using_pct,
      callsites_pct
    )
}

projects_using_parameter <- function(name, id) {
  projects_using(name, match_parameter_id(id))
}

overview_pattern2 <- function(xs, keys=names(xs)) {
  items <-
    xs %>% 
      gather("key", "value", -(pattern:cat)) %>%
      filter(key %in% keys) %>%
      transmute(
        value=ifelse(endsWith(key, "_pct"), fmt(percent(value)), fmt(value)),
        key=str_c(pattern, " ", cat, " ", key),
        key=str_replace_all(key, "_", " ")
      )
  overview(map2_dfr(items$key, items$value, ~r(.x, .y)))
}

overview_table(
  overview_pattern2(
    projects_using_parameter("IP scala collection", "^scala/collection/generic/CanBuildFrom#$"),
     c("projects_using_pct", "callsites_pct")
  ),
  overview_pattern2(
    projects_using_parameter("IP scala reflection", "^scala/reflect/.*"),
     c("projects_using_pct", "callsites_pct")
  ),
  overview_pattern2(
    projects_using_parameter("IP scala concurrency", "^scala/concurrent/ExecutionContext#$"),
     c("projects_using_pct", "callsites_pct")
  )
)
```

#### Top projects

```{r}
IP_ds_per_project <- count(pattern_implicit_parameters_ds, project_id)
IP_cs_per_project <- count(pattern_implicit_parameters_cs, project_id)
IP_declaration    <- count(pattern_implicit_parameters_cs, def_library, declaration_id)
save_top_n_projects(IP_ds_per_project, IP_cs_per_project, path(output_dir, "IP-top-projects.tex"))
```

### Implicit Not Found

```{r pattern custom error, eval=F}
match_implicit_not_found <- function(df) {
  filter(df, str_detect(type_annotations, "scala/annotation/implicitNotFound#"))
}

match_implicit_not_found(type_class_types_local)
match_implicit_not_found(type_class_types_all) %>% distinct(type_library, type_id)
```

### Unrelated Conversions

#### Primitive

For the top most ones!

% projects using
% projects definining
% defintions
% usage

```{r}
SCALA_PRIMITIVES <- c(
  "scala/Any#",
  "scala/AnyRef#",
  "scala/AnyVal#",
  "scala/Boolean#",
  "scala/Byte#",
  "scala/Char#",
  "scala/Double#",
  "scala/Float#",
  "scala/Int#",
  "scala/Long#",
  "scala/Short#",
  "scala/StringContext#",
  "scala/Unit#",
  "java/lang/String#"
)

declaration_is_scala_primitive <- function(x) {
  x %in% SCALA_PRIMITIVES
}
```


#### From Java / To Java

```{r implicit conversion java to java data}
match_IC_java_to_java <- function(df) {
  filter(df, from_language=="JAVA", to_language=="JAVA")
}

IC_java_to_java_ds <- match_IC_java_to_java(conversions_local)
IC_java_to_java_cs <- match_IC_java_to_java(conversions_all) %>% match_callsites()

IC_java_to_java <- pattern_summary("ICJJ", IC_java_to_java_ds, IC_java_to_java_cs)
IC_java_to_java_sum <- compute_pattern_overview(IC_java_to_java)
IC_java_to_java_all_row <- compute_pattern_overview_all_row(IC_java_to_java)

print_pattern_overview(IC_java_to_java_sum)
```

```{r}
IC_java_to_java_ds %>% select(from, from_group_id, to, to_group_id)
```


```{r implicit conversion java to java analysis}
overview_table(
  overview_pattern(pattern_info("ICJJ", "all", IC_java_to_java_all_row))
)
```

```{r}
filter(pattern_implicit_conversions_ds, from_language=="JAVA", to_language=="JAVA") %>% View()
IC_from_java <- 
  filter(pattern_implicit_conversions_ds, from_language=="JAVA") %>% 
  select(declaration_id=from, group_id=from_group_id, artifact_id=from_artifact_id)
```

### Type Classes - Types (TCT)

```{r pattern type classes types, eval=F}
type_class_types_all <- 
  parameters_all_type_classes %>%
  filter(
    # skip type aliases
    type_id == resolved_type_id
  ) %>% 
  distinct(mid, resolved_type_id, .keep_all=T) %>%
  select_at(vars(pid, mid, project_id, module_id, resolved_type_id, starts_with("type_"))) %>%
  # this is to look like a ds / cs for the pattern_summary
  mutate(
    declaration_id=resolved_type_id,
    def_is_in_test=type_is_in_test,
    is_in_test=type_is_in_test
  )

type_class_types_local <-
  type_class_types_all %>% 
  filter(
    is_module_local(type_location_uri),
  )

#pattern_type_class_t <- pattern_summary("TCT", type_class_types_local, type_class_types_all)
```

### TODO: Context - types
