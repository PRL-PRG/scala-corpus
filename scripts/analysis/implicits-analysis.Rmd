---
title: Implicit Analysis
authors: Filip Krikava, Heather Miller and Jan Vitek
output:
  html_document:
    code_folding: hide
    theme: united
    toc: true
    toc_float: true
params:
  corpus_dir: /var/lib/scala/corpora/github
  corpus_url: http://prl1.ele.fit.cvut.cz:8149
  lib_dir: ../inc
  report_name: implicits-analysis
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
source(file.path(params$lib_dir, "setup.R"))
```

```{r}
OUT_IMPLICITS_OVERVIEW_PDF <- path(output_dir, "implicits-overview.pdf")
```

## Introduction

The notebook contains the automated analysis of the results of the implicits extraction pipeline.
Some of the analysis in the paper was done manually by inspecting the data presented in the tables rendered by this script.

## Data Definition

The following is the summary of the data exported from the corpus.

### Implicit Declarations

The `r CLEAN_IMPLICIT_DECLARATIONS` file contains all the implicit declarations, including all defs with implicit parameters.
It contains the following columns:

- `project_id` (chr): project name as `github-user-name--github-repository-name`
- `module_id` (chr): module id as `project_id::group_id:artifact_id:version:platform`
- `group_id` (chr): organization name
- `artifact_id` (chr): artifact name
- `version` (chr): version
- `kind` (chr): one of `DEF`, `CLASS`, `VAL`, `VAR`, `OBJECT`, `MACRO`, `PARAMETER`
- `declaration_id` (chr): fully qualified name of the declaration
- `name` (chr): just the declaration name
- `location_path` (chr): the folder or jar file in which it is defined
- `location_uri` (chr): the file name within that folder or jar file
- `location_pos` (chr): `start_line:start_coulmn` in case it was available or `NA`
- `location_scope` (chr): a `;`-separated tags:
    - `compile` - in a compile scope
    - `test` - in a test scope
    - `managed` - in an SBT managed directory (i.e. a generated source)
    - `dependency` - in a dependency in respect to the module (group_id:artifact_id)
    - `transitive` - in a transitive depenency
- `compilation_unit` (chr): the fully qualified name of the enclosing compilation unit
- `def_group_id` (chr): the organization name of the library where the decalration originates
- `def_artifact_id` (chr): the artifact name of the library where the decalration originates
- `def_version` (chr): the version of the library where the decalration originates
- `is_implicit` (lgl): does it come with the `implicit` keyword?
- `is_companion` (lgl): is it the `implicit def` generated for an `implicit class`?
- `access` (chr): access modifiers (e.g. `PUBLIC`, `PRIVATE`, ...)
- `annotations` (char): a `;`-separated list of attached annotation 
- `num_type_parameters` (int): number of type parameters it defines
- `num_parameter_lists` (int): number of parameter lists
- `num_parameters` (int): total number of parameters
- `num_implicit_parameters` (int): number of implicit parameters
- `github_url` (chr): a link to github if available to see the actual code

It was created by [ImplicitDeclarationExporter.scala](https://github.com/PRL-PRG/scala-implicits-analysis/blob/oopsla19/libs/tools/src/main/scala/cz/cvut/fit/prl/scala/implicits/tools/ 	ImplicitDeclarationExporter.scala).

### Implicit Call Sites

The `r CLEAN_IMPLICIT_CALLSITES` file contains all the callsites involving implicits.
It contains the following columns:

- `project_id` (chr): project name as `github-user-name--github-repository-name`
- `module_id` (chr): module id as `project_id::group_id:artifact_id:version:platform`
- `group_id` (chr): organization name
- `artifact_id` (chr): artifact name
- `version` (chr): version
- `callsite_id` (int): an id of a call site which is unique within a module
- `parent_id` (int): an id to a parent call site in the case this one is nested or `NA`
- `code` (chr): an up to 50 chars snippet of the call site code
- `nested_calls` (chr): `;`-separated list of call nested call sites
- `arguments` (chr): `;`-separated list of arguments declaration ids
- `declaration_id` (chr): a declaration id of the function/method
- `local` (chr): is it `project`-local, `module`-local or `NA`
- `location_path` (chr): the folder or jar file in which it is defined
- `location_uri` (chr): the file name within that folder or jar file
- `location_pos` (chr): `start_line:start_coulmn` in case it was available or `NA`
- `location_scope` (chr): a `,`-separated tags:
    - `compile` - in a compile scope
    - `test` - in a test scope
    - `managed` - in an SBT managed directory (i.e. a generated source)
    - `dependency` - in a dependency in respect to the module (group_id:artifact_id)
    - `transitive` - in a transitive depenency
- `num_type_parameters` (int): number of type parameters it has
- `num_implicit_parameters` (int): number of implicit parameters
- `github_url` (chr): a link to github if available to see the actual code

It was created by [ImplicitCallSitesExporter.scala](https://github.com/PRL-PRG/scala-implicits-analysis/blob/oopsla19/libs/tools/src/main/scala/cz/cvut/fit/prl/scala/implicits/tools/ 	ImplicitCallSitesExporter.scala).

### Implicit Conversions

The `r CLEAN_IMPLICIT_CONVERSIONS` file contains all the callsites involving implicits.
It contains the following columns:

- `project_id` (chr): project name as `github-user-name--github-repository-name`
- `module_id` (chr): module id as `project_id::group_id:artifact_id:version:platform`
- `declaration_id` (chr): a declaration id of the implicit conversion
- `from` (chr): a declaration id of the from parameter
- `from_groupId` (chr): organization name of the library where from is defined
- `from_artifactId` (chr): artifact name of the library where from is defined
- `from_version` (chr): version of the library where from is defined
- `from_scope` (chr): a `,`-separated tags:
    - `compile` - in a compile scope
    - `test` - in a test scope
    - `managed` - in an SBT managed directory (i.e. a generated source)
    - `dependency` - in a dependency in respect to the module (group_id:artifact_id)
    - `transitive` - in a transitive depenency
- `from_compilation_unit` (chr): the fully qualified name of the enclosing compilation unit of the to parameter
- `from_language` (chr): either `SCALA` or `JAVA`
- `to` (chr): a declaration id of the to parameter
- `to_groupId` (chr): organization name of the library where to is defined
- `to_artifactId` (chr): artifact name of the library where to is defined
- `to_version` (chr): version of the library where to is defined
- `to_scope` (chr): a `,`-separated tags:
    - `compile` - in a compile scope
    - `test` - in a test scope
    - `managed` - in an SBT managed directory (i.e. a generated source)
    - `dependency` - in a dependency in respect to the module (group_id:artifact_id)
    - `transitive` - in a transitive depenency
- `to_compilation_unit` (chr): the fully qualified name of the enclosing compilation unit of the to parameter
- `to_language` (chr): either `SCALA` or `JAVA`

It was created by [ImplicitConversionExporter.scala](https://github.com/PRL-PRG/scala-implicits-analysis/blob/oopsla19/libs/tools/src/main/scala/cz/cvut/fit/prl/scala/implicits/tools/ 	ImplicitConversionExporter.scala).

### Implicit parameters

The data frame in `r CLEAN_IMPLICIT_PARAMETERS` represents implicit parameter declarations.
For each declaration that carries implicit argument list it contains the following information:

- `project_id` (chr): project name as `github-user-name--github-repository-name`
- `module_id` (chr): module id as `project_id::group_id:artifact_id:version:platform`
- `group_id` (chr): organization name
- `artifact_id` (chr): artifact name
- `version` (chr): version
- `declaration_id` (chr): a declaration id of the implicit conversion
- `declaration_kind` (chr): kind of the declaration
- `declaration_is_implicit` (lgl): is the declaration implicit
- `declaration_is_companion` (lgl): is the declaration a companion def to an implicit class
- `def_group_id` (chr): organization name that defines this declaration
- `def_artifact_id` (chr): artifact name that defines this declaration 
- `def_version` (chr): artifact version
- `def_location_scope`  (chr): a `,`-separated tags:
    - `compile` - in a compile scope
    - `test` - in a test scope
    - `managed` - in an SBT managed directory (i.e. a generated source)
    - `dependency` - in a dependency in respect to the module (group_id:artifact_id)
    - `transitive` - in a transitive depenency
- `parameter_id` (chr): id of the parameter
- `name` (chr): name of the parameter
- `code` (chr): code representation
- `type_id` (chr): id of the parameter type
- `type_kind` (chr): kind of the parameter type
- `type_group_id` (chr): organization name that defines this type
- `type_artifact_id` (chr): artifact name that defines this type
- `type_version` (chr): version of the artifact
- `type_location_scope` (chr): a `,`-separated tags:
    - `compile` - in a compile scope
    - `test` - in a test scope
    - `managed` - in an SBT managed directory (i.e. a generated source)
    - `dependency` - in a dependency in respect to the module (group_id:artifact_id)
    - `transitive` - in a transitive depenency
- `type_local` (chr): either `project` or `module` local, or `NA` for for project external symbols
- `resolved_type_id` (chr): resolved type declaration id
- `resolved_type_kind` (chr): resolved type kind
- `num_type_arguments` (int): number of type arguments the type declaration has
- `num_type_argument_refs` (int): number of type arguments the type declaration has that are type parameters

They were extracted using [ImplicitParameterExporter.scala](https://github.com/PRL-PRG/scala-implicits-analysis/blob/oopsla19/libs/tools/src/main/scala/cz/cvut/fit/prl/scala/implicits/tools/ImplicitParameterExporter.scala).

## Tests

```{r}
testthat::expect_equal(
  remove_scala_version_suffix(
    c("name_scala_6.2", "name_scala-ng_3.2", "name-scala_2-5", "name-scala_2.11", "name-scala_sjs0.6", "name_scala_native0.3", "name-scala_6.2_sjs0.6_2.12")
  ), 
    c("name_scala",     "name_scala-ng",     "name-scala",     "name-scala",      "name-scala",        "name_scala",           "name-scala")
)
```

## Loading data

First, we load the corpus and raw data that came from the `export-implicit` task.

```{r loading declarations}
raw_corpus <- load_if_not_present(raw_corpus, read_csv(CLEAN_CORPUS))
raw_all_declarations <- load_if_not_present(raw_all_declarations, read_data(CLEAN_IMPLICIT_DECLARATIONS))
raw_all_callsites <- load_if_not_present(raw_all_callsites, read_data(CLEAN_IMPLICIT_CALLSITES))
raw_all_conversions <- load_if_not_present(raw_all_conversions, read_data(CLEAN_IMPLICIT_CONVERSIONS))
raw_all_parameters <- load_if_not_present(raw_all_parameters, read_data(CLEAN_IMPLICIT_PARAMETERS))
```

Double check there are no duplicates!

```{r}
stopifnot(!any(duplicated(raw_corpus$project_id)))
```

Double check we agree on projects

```{r}
stopifnot(raw_all_declarations %>% anti_join(raw_corpus, by="project_id") %>% nrow() == 0)
stopifnot(raw_all_callsites %>% anti_join(raw_corpus, by="project_id") %>% nrow() == 0)
stopifnot(raw_all_conversions %>% anti_join(raw_corpus, by="project_id") %>% nrow() == 0)
stopifnot(raw_all_parameters %>% anti_join(raw_corpus, by="project_id") %>% nrow() == 0)
```

```{r}
JOIN_BY <- c("module_id", "declaration_id")
```


```{r, include=F}
reset_environment <- function() {
  vars <- ls(envir = globalenv())
  vars <- vars[!startsWith(vars, "raw_all")]
  message("Removing: ", str_c(vars, ", "))
  rm(list=vars, envir=globalenv())
}
```

Note: 
- The conditional load is for interactive development of this notebook.
  Loading takes time and they these variables should only be used to derive the actual variables with which we work.

## Preprocessing

TODO: do we need the `expand_module_name`?

```{r all declarations}
all_declarations <- 
  raw_all_declarations %>%
  expand_module_name() %>%
  expand_platform() %>%
  expand_location() %>%
  expand_access_info() %>%
  expand_is_from_scala() %>%
  mark_block_locals() %>%
  clean_block_locals()
```

```{r check declarations}
stopifnot(all(count(all_declarations, platform)$platform %in% c("jvm", "js", "native")))
stopifnot(nrow(filter(all_declarations, startsWith(declaration_id, "_local_"), !is_block_local)) == 0)
stopifnot(nrow(raw_all_declarations) == nrow(all_declarations))
```

Check the mutually exclusive flags:

```{r all declarations check, eval=F}
check_all_declarations <-
  all_declarations %>%
    rowwise() %>%
    mutate(
      check_platform=sum(is_jvm, is_js, is_native),
      check_access=if (is_access_specified) sum(is_public, is_private, is_protected) else 1
    ) %>%
    filter(
      check_platform != 1,
      check_access != 1
    )

stopifnot(nrow(check_all_declarations) == 0)
rm(check_all_declarations)
```

```{r callsites}
all_callsites <- 
  raw_all_callsites %>%
  expand_module_name() %>%
  expand_location() %>%
  mark_block_locals() %>%
  clean_block_locals()
```

```{r}
stopifnot(nrow(raw_all_callsites) == nrow(all_callsites))
```

```{r conversions}
all_conversions <- 
  raw_all_conversions %>%
  expand_module_name() %>%
  mark_block_locals() %>%
  clean_block_locals()
```

```{r parameters}
all_parameters <- 
  raw_all_parameters %>%
  expand_module_name() %>%
  mark_block_locals() %>%
  clean_block_locals()
```

### Joining data

```{r}
declarations <-
  all_declarations %>%
  mutate(
    def_artifact_id=remove_scala_version_suffix(def_artifact_id),
    def_library=str_c(def_group_id, ":", def_artifact_id),
    num_implicit_parameters=replace_na(num_implicit_parameters, 0)
  ) %>%
  filter(
    kind != "CLASS",    # remove implicit class as it is there already in the desugared version
    kind != "PARAMETER" # remove parameters since they are also in defs
  )
```

```{r}
callsites <-
  left_join(
    all_callsites,
    select(
      declarations, 
      module_id,
      declaration_id, 
      is_access_specified,
      is_public,
      is_from_scala,
      def_group_id,
      def_library
    ),
    by=c("module_id", "declaration_id")
  )
```

```{r}
stopifnot(nrow(callsites) == nrow(raw_all_callsites))
```

TODO: rename from_artifactId in exporter 
TODO: rename to_artifactId in exporter

```{r}
conversions <-
  all_conversions %>%
  mutate(
    from_artifact_id=remove_scala_version_suffix(from_artifact_id),
    from_library=str_c(from_group_id, ":", from_artifact_id),
    to_artifact_id=remove_scala_version_suffix(to_artifact_id),
    to_library=str_c(to_group_id, ":", to_artifact_id),
  ) %>%
  left_join(
    select_at(
      declarations,
      vars(
        module_id,
        declaration_id, 
        kind,
        name,
        compilation_unit,
        def_group_id,
        def_library,
        def_location_path=location_path,
        def_location_uri=location_uri,
        num_type_parameters,
        num_parameters,
        num_implicit_parameters,
        github_url,
        starts_with("is_")
      )
    ),
    by=c("module_id", "declaration_id")
  ) %>%
  distinct(def_library, declaration_id, .keep_all=TRUE) %>%
  select(-module_id, -module_name, -group_id, -artifact_id, -project_id) %>%
  filter(!is.na(kind))
```

TODO: check the filter(conversions, is.na(kind))

## Implicits overview

### Local implicits declarations

```{r}
local_declarations <- 
  declarations %>%
  filter(is_module_local)
```

All local declarations should have a path (otherwise, how could they be local)

```{r}
stopifnot(all(!is.na(local_declarations$path)))
```

Duplication in module local declarations

```{r}
stopifnot(
  local_declarations %>% 
  semi_join(
    count(filter(local_declarations, !is_block_local), path, module_id, declaration_id) %>% filter(n > 1), 
    by = c("module_id", "path")
  ) %>%
  nrow() == 0)
```

There are duplicates in the corpus. They do not need to be full project clones, just few files.
Since we do not have any reliable way of telling which one is original and the overall level is low, we keep them.

```{r}
local_declarations_duplication <-
  local_declarations %>% 
  semi_join(
    count(local_declarations, def_library, declaration_id) %>% filter(n > 1), 
    by=c("declaration_id", "def_library")
  )

overview_table(
  r("Duplicate local declarations", local_declarations_duplication),
  r("Duplicate local declarations pct", ratio(local_declarations_duplication, local_declarations)),
  r("Corpus dejavu duplication mean pct", percent(mean(raw_corpus$dejavu_duplication, na.rm=T)))
)
```

### External implicit declarations

```{r}
external_declarations <-
  declarations %>% 
  anti_join(local_declarations, by=c("module_id", "declaration_id")) %>%
  anti_join(local_declarations, by=c("def_library", "declaration_id"))
```

#### Find unique ones

External implicit declarations can be uniquely identified using their fully qualified name (`declaration_id`) and the artifact in which they were declared (`def_library_full`). 
We disregard library version.

```{r compute unique implicit declarations}
filter_unique_declarations <- function(df) {
  df %>%
  distinct(def_library, declaration_id, .keep_all=T) %>%
  # these no longer applies - in which project/module it has been seen
  select(-project_id, -module_id, -group_id, -artifact_id, -version, -def_version, -is_module_local) %>%
  select(declaration_id, def_library, def_group_id, def_artifact_id, everything())
}
```

```{r}
unique_external_declarations <- 
  external_declarations %>%
  filter_unique_declarations()
```

Internal and external should not overlap

```{r}
stopifnot(nrow(semi_join(local_declarations, unique_external_declarations, by=c("def_library", "declaration_id"))) == 0)
```

#### Combined local and external

```{r}
unique_declarations <-
  bind_rows(
    select(local_declarations, -project_id, -module_id, -artifact_id, -group_id, version),
    unique_external_declarations
  )
```

### Block local declarations

```{r}
block_local_declarations <- filter(unique_declarations, is_block_local)
overview_table(
  r("block local implicit declarations", block_local_declarations),
  r("block local implicit declarations pct", ratio(block_local_declarations, unique_declarations))
)
```

```{r}
add_corpus_column_count <- function(df, from, column) {
  column <- enquo(column)
  
  df %>%
    left_join(count(from, project_id), by="project_id") %>% 
    mutate(n=replace_na(n, 0)) %>% 
    rename(!!column:=n)
}

corpus <- 
  raw_corpus %>%
  # drop the approximations from implicit-stats.csv
  select(
    -implicit_declarations,
    -implicit_local_declarations,
    -implicit_callsites,
    -implicit_test_callsites
  ) %>%
  add_corpus_column_count(declarations,                          implicit_declarations) %>%
  add_corpus_column_count(filter(declarations, is_module_local), implicit_local_declarations) %>%
  add_corpus_column_count(callsites,                             implicit_callsites) %>%
  add_corpus_column_count(filter(callsites, is_in_test),         implicit_test_callsites) %>%
  mutate(
    callsites=explicit_callsites + implicit_callsites,
    test_callsites=explicit_test_callsites + implicit_callsites
  )
```

```{r implicits overview}
n_callsites          <- sum(corpus$callsites)
n_explicit_callsites <- sum(corpus$explicit_callsites)
n_implicit_callsites <- sum(corpus$implicit_callsites)

stopifnot(n_callsites == n_explicit_callsites + n_implicit_callsites)
```

```{r}
n_explicit_test_callsites <- sum(corpus$explicit_test_callsites)
n_implicit_test_callsites <- sum(corpus$implicit_test_callsites)
n_test_callsites          <- n_explicit_test_callsites + n_implicit_test_callsites  

stopifnot(n_test_callsites == n_explicit_test_callsites + n_implicit_test_callsites)
```

```{r}
projects_using_implicits <- filter(corpus, implicit_callsites > 0)
projects_defining_implicits <- filter(corpus, implicit_local_declarations > 0)

overview_table(
  r("implicit extraction errors", sum(corpus$implicit_extraction_errors)),
  r("implicit extraction failures", filter(corpus, !is.na(implicit_failure))),
  r("implicit declarations", unique_declarations),
  r("local implicit declarations", local_declarations),
  r("local implicit declarations pct", ratio(local_declarations, unique_declarations)),
  
  r("call sites", n_callsites),
  r("explicit call sites", n_explicit_callsites),
  r("implicit call sites", n_implicit_callsites),
  r("implicit call sites pct", percent(n_implicit_callsites/n_callsites)),
  
  r("test call sites", n_explicit_test_callsites),
  r("test call sites pct", percent(n_explicit_test_callsites/n_explicit_callsites)),
  r("implicit test call sites", n_implicit_test_callsites),
  r("implicit test call sites pct", percent(n_implicit_test_callsites/n_test_callsites)),
  
  r("projects using implicits", projects_using_implicits),
  r("projects defining implicits", projects_defining_implicits),
  r("projects using implicits pct", ratio(projects_using_implicits, corpus)),
  r("projects defining implicits pct", ratio(projects_defining_implicits, corpus))
)
```

#### Graph

```{r implicit overview}
local({

callsite_color <- "darkblue" #"#ED6559"
declaration_color <-"darkgoldenrod1"    #"#4C5D7C"
  
# the trick with superposition is to do the log10 scaling manually
corpus_implicitness_overview <- 
  corpus %>%
  mutate(
    implicit_local_declarations=if_else(implicit_local_declarations > 0, log10(implicit_local_declarations), 0)
  )

# up to which part of the implicit local declarations can this graph overlap
cs_ds_opverlap <- 1
cs_end <- max(corpus_implicitness_overview$implicit_local_declarations)
# this is the height of the overlap which is equal to 100% of implicit callsites ration
cs_height <- cs_end - 10^(log10(cs_end) - log10(cs_end) * cs_ds_opverlap)

# the implicit callsites ratio will be plotted using segments
# for this we need to compute y and yend (x and xend are the same - project_id)
corpus_implicitness_overview <- 
  corpus_implicitness_overview %>%
  transmute(
    project_id,
    ds=implicit_local_declarations,
    cs=implicit_callsites/callsites,
    cs_start=cs_end - cs_height * cs
  ) %>%
  mutate(
    project_id=forcats::fct_reorder(project_id, ds)
  )

pri_breaks <- seq(cs_end, cs_end*(1-cs_ds_opverlap), length.out = 5)
pri_labels <- seq(0, 100, length.out = length(pri_breaks)) %>% str_c("%")
sec_breaks <- c(0:as.integer(cs_end), cs_end)
sec_labels <- c("0", fmt(10^sec_breaks[-1]))

corpus_implicitness_overview %>%
  ggplot(
    aes(
      x=project_id,
      y=ds
    )
  ) + 
  geom_segment(aes(xend=project_id, y=cs_start, yend=cs_end),
               color=callsite_color, alpha=.5) +
  geom_bar(width=1, stat="identity",
           fill=declaration_color, alpha=.7) +
  theme(
    axis.ticks.x=element_blank(),
    axis.ticks.y=element_line(),
    panel.grid.major.x=element_blank(), 
    panel.grid.minor.x=element_blank(),
    panel.grid.major.y=element_line(),
    panel.grid.minor.y=element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_text(color = "grey20", size = 10),
    axis.title.x = element_text( size = 11),
    axis.title.y = element_text( size = 11)
  ) + 
  scale_y_continuous(
    breaks=pri_breaks,
    labels=pri_labels,
    name="Ratio of implicit calls",
    sec.axis=sec_axis(
      trans=~.,
      name="Number of implicit declarations (log)",
      breaks=sec_breaks, 
      labels=sec_labels
    ) 
  ) +
  labs(x="Projects")
})
```

```{r save implicits overview plot}
ggsave(OUT_IMPLICITS_OVERVIEW_PDF)
```

## Other platforms

```{r}
projects_other_platform <- 
  count(filter(declarations, is_js | is_native), project_id) %>% 
  select(project_id) %>%
  semi_join(corpus, ., by="project_id")

overview_table(
  overview_projects("projects targeting other platform", projects_other_platform ),
  r("projects targeting JVM", count(filter(declarations, is_jvm), project_id)),
  r("projects targeting JS", count(filter(declarations, is_js), project_id)),
  r("projects targeting native", count(filter(declarations, is_native), project_id))
)
```

## Analyzing Implicits Usage

### Overview Table

```{r}
stat_row <- function(name, code, ds, cs) {
  ds_unique <- distinct(ds, def_library, declaration_id)
  if (missing(cs)) {
    cs <- semi_join(callsites, ds, by=c("def_library", "declaration_id"))
  }
  
  tibble(
    name=                   name,
    code=                   code,
    
    declarations_all=       nrow(ds_unique),
    declarations_all_pct=   declarations_all/nrow(declarations_unique),
    
    declarations_local=     nrow(filter(ds, is_module_local)),
    declarations_local_pct= declarations_local/nrow(declarations_unique),
    
    callsites=              nrow(cs),
    callsites_pct=          callsites/nrow(all_callsites),
    
    callsites_test=         nrow(filter(cs, is_in_test)),
    callsites_test=         nrow(filter(cs, is_in_test)),
  )
}

#ds_def_with_iparams <- filter(declarations_unique, kind=="DEF", num_implicit_parameters > 1)

stats <- bind_rows(
  stat_row("Overall",              "ALL", declarations),
  stat_row("Implicit conversions", "IC",  conversions)
)

my_datatable(stats)
```


### Implicit conversions

```{r}
conversions_callsites <- semi_join(callsites, conversions, by=c("def_library", "declaration_id"))
conversions_test_callsites <- filter(conversions_callsites, is_in_test)
```

```{r}
projects_using_implicit_conversion <- count(conversions_callsites, project_id)
projects_using_implicit_conversion_non_scala <- filter(conversions_callsites, !is_from_scala) %>% count(project_id)
projects_using_implicit_conversion_non_test <- filter(conversions_callsites, !is_in_test) %>% count(project_id)

n_implicit_test_callsites <- nrow(filter(callsites, is_in_test))
n_all_test_callsites <- n_implicit_test_callsites + sum(corpus$explicit_test_callsites)

conversion_from_scala <- filter(conversions_callsites, is_from_scala)

test_libraries_patterns <- c(
  "^org.scalatest:.*",
  "^org.spec2:.*",
  "^org.scalastic:.*",
  "^com.lihaoyi:utest.*"
)

conversion_from_testlib <- 
    map_dfr(test_libraries_patterns, ~filter(conversions_callsites, str_detect(def_library, .)))
```

```{r}
overview_table(
  r("projects using implicit conversion", projects_using_implicit_conversion),
  r("projects using implicit conversion pct", percent(nrow(projects_using_implicit_conversion)/nrow(corpus))),
  
  r("conversion callsites", conversions_callsites),
  r("conversion callsites in all implicit callsites pct", percent(nrow(conversions_callsites)/nrow(callsites))),
  r("conversion callsites in all callsites pct", percent(nrow(conversions_callsites)/sum(corpus$callsites))),
  
  r("conversion test callsites", conversions_test_callsites),
  r("conversion test callsites in all conversion pct", percent(nrow(conversions_test_callsites)/nrow(conversions_callsites))),
  r("conversion test callsites in all implicit test callsites pct", percent(nrow(conversions_test_callsites)/n_implicit_test_callsites)),
  r("conversion test callsites in all test callsites pct", percent(nrow(conversions_test_callsites)/n_all_test_callsites)),
  
  r("conversion callsites from scala pct", percent(nrow(conversion_from_scala)/nrow(conversions_callsites))),
  r("conversion callsites from scala test libraries", percent(nrow(conversion_from_testlib)/nrow(conversions_callsites)))
)
```

- all declarations
- local declarations
- main call sites
- test call sites
- projects using it
- projects declarng it

```{r}
stat_row <- function(name, code, ds, cs) {
  ds_unique <- distinct(ds, def_library, declaration_id)
  if (missing(cs)) {
    cs <- semi_join(callsites, ds, by=c("def_library", "declaration_id"))
  }
  
  tibble(
    name=                   name,
    code=                   code,
    
    declarations_all=       nrow(ds_unique),
    declarations_all_pct=   declarations_all/nrow(declarations_unique),
    
    declarations_local=     nrow(filter(ds, is_module_local)),
    declarations_local_pct= declarations_local/nrow(declarations_unique),
    
    callsites=              nrow(cs),
    callsites_pct=          callsites/nrow(all_callsites),
    
    callsites_test=         nrow(filter(cs, is_in_test)),
    callsites_test=         nrow(filter(cs, is_in_test)),
  )
}

#ds_def_with_iparams <- filter(declarations_unique, kind=="DEF", num_implicit_parameters > 1)

stats <- bind_rows(
  stat_row("Overall",              "ALL", declarations),
  stat_row("Implicit conversions", "IC",  conversions)
)

my_datatable(stats)
```

### Late trait implementation

#### Using implicit class

```{r}

```


```{r}
implicit_classes_from_raw_declarations <- filter(declarations, kind=="CLASS") %>% distinct(def_library, declaration_id)
implicit_classes <- filter(conversions, is_companion)
implicit_classes_extending_traits <- filter(conversions, is_companion, to_extends_trait)
implicit_classes_extending_traits_def_libraries <- count(implicit_classes_extending_traits , def_library)

arrange(implicit_classes_extending_traits_def_libraries, desc(n))

overview_table(
  r("Implicit classes", implicit_classes),
  r("Implicit classes extending traits", implicit_classes_extending_traits),
  r("Implicit classes extending traits in all implicit classes pct", ratio(implicit_classes_extending_traits, implicit_classes))
)
```



## Implicit parameters

## Patterns

### Extension methods

```{r}
filter(conversions, !is_companion) %>% View()
filter(conversions, is_companion)
```







## Other

```{r}
my_top_count <- function(df, wt, N=50) {
  count(df, !!enquo(wt)) %>% arrange(desc(n)) %>% print(n=N)
}
```

```{r}
my_top_count(conversions_callsites, def_library)
my_top_count(filter(conversions_callsites, !is_in_test), def_library)
my_top_count(filter(conversions_callsites, !is_in_test, !is_from_scala), def_library)
```


```{r}
conversions_callsites_per_project <- 
  conversions_callsites %>%
  count(project_id, def_library, declaration_id)

conversions_callsites_cumul_per_projects <-
  conversions_callsites %>%
  count(project_id)

converions_popularity <-
  left_join(
    conversions_callsites_per_project,
    rename(conversions_callsites_cumul_per_projects, all=n),
    by="project_id"
  ) %>%
  mutate(
    r=n/all
  )
```

```{r}
count(conversions_callsites, def_library, def_library_full) %>%
  left_join(project_libraries, by="def_library_full") %>%
  mutate(def_project=ifelse(is.na(def_project), def_library, def_project)) %>%
  select(def_project, n) %>%
  group_by(def_project) %>%
  summarise(n=sum(n)) %>%
  arrange(desc(n))

```


```{r}
  conversions_callsites %>%
  count(def_library, declaration_id, project_id) %>%
  count(def_library, declaration_id) %>%
  arrange(desc(n)) %>%
  View()
```


```{r}
local({
  threshold <- .03
  all_main <- nrow(conversions_callsites)-nrow(conversions_test_callsites)
  all_test <- nrow(conversions_test_callsites)
  
  main_vs_test <- all_main/(all_main + all_test)

  conversion_callsites_summaries <- 
    conversions_callsites %>%
    group_by(def_library) %>%
    summarise(main=sum(!is_in_test)/all_main, test=sum(is_in_test)/all_test) %>%
    gather("key", "value", main, test)

  top_libraries <- 
    filter(conversion_callsites_summaries, value >= threshold)
 
  df <- 
    top_libraries %>%
    add_row(
      def_library="rest",
      key="main",
      value=1-sum(filter(top_libraries, key=="main")$value)
    ) %>%
    add_row(
      def_library="rest",
      key="test",
      value=1-sum(filter(top_libraries, key=="test")$value)
    ) %>%
    group_by(key) %>%
    arrange(value) %>%
    mutate(
      ymax=cumsum(value),
      ymin=ymax-value,
      xmin=if_else(key=="main", 0, main_vs_test),
      xmax=if_else(key=="main", main_vs_test, 1),
      x=xmin+(xmax-xmin)/2,
      y=ymin+(ymax-ymin)/2
    ) %>%
    arrange(key, value)

  stopifnot(sum(filter(df, key=="main")$value)==1)
  stopifnot(sum(filter(df, key=="test")$value)==1)
    
  df %>%
    ggplot(aes(x=x, y=y, xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=def_library, label=def_library)) + 
    geom_rect() +
    geom_text(aes(color=ifelse(value > .2, "light", "dark"))) +
    scale_fill_brewer("Greens") +
    scale_x_continuous(
      breaks=c(main_vs_test/2, main_vs_test+(1-main_vs_test)/2),
      labels=c("Main code", "Test code")
    ) +
    scale_color_manual(
      values=c("light"="white", "dark"="black"),
    ) +
    guides(
      color=F,
      fill=F
    ) +
    theme(
      axis.title = element_blank(),
      axis.ticks = element_blank(),
      panel.grid = element_blank(),
      axis.text.y = element_blank(),
      axis.text.x = element_text(size=12)
    )
})
```


```{r}
count(conversion_callsites, project_id) %>% arrange(desc(n))
count(all_conversions, project_id) %>% arrange(desc(n))
```

```{r}
projects_not_using_implicit_conversion <- anti_join(corpus, projects_using_implicit_conversion, by="pid")
```

```{r}

```


- from java / scala
- both ways
- scala collections
- primitives
- unrelated

```{r}
x <- count(conversion_from_testlib, project_id) %>% left_join(select(corpus, project_id, metadata_scala_code, gh_stars))
x <-
  x %>%
  select(-project_id) %>%
  mutate(
    gh_stars=if_else(gh_stars==0, 0, log10(gh_stars)),
    metadata_scala_code=if_else(metadata_scala_code==0, 0, log10(metadata_scala_code)),
    n=if_else(n==0, 0, log10(n))
  )
  
y_bins <- seq(0, max(x$gh_stars), length.out = 23)
y_size <- max(x$gh_stars)/22
x_bins <- seq(0, max(x$metadata_scala_code), length.out = 23)
x_size <- max(x$metadata_scala_code)/22

x %>%
  transmute(
    n,
    x=cut(metadata_scala_code, breaks = x_bins),
    y=cut(gh_stars, breaks = y_bins)
  ) %>%
  ggplot(aes(x=x, y=y, fill=n, width=x_size*4, height=y_size*4))  + geom_tile() + coord_fixed()
#x %>% ggplot(aes(x=metadata_scala_code, y=gh_stars, fill=n))  + geom_tile()
```
